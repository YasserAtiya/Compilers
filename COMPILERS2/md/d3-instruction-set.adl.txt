constant
   logical_name_space    70,
   cpc_register_number   32,
   lo_hi_register_number 32;

# ISA Test
set float_registers [0:32]
      (
      "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
      "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
      "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
      "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31",
      "$CpC"
      ),
    integer_registers [0:31]
      (
      "$0",  "$1",  "$2",  "$3",  "$4",  "$5",  "$6",  "$7",
      "$8",  "$9",  "$10", "$11", "$12", "$13", "$14", "$15",
      "$16", "$17", "$18", "$19", "$20", "$21", "$22", "$23",
      "$24", "$25", "$26", "$27", "$28", "$29", "$30", "$31"
      ),
    integer_register_alias [0:31]
      (
      "$zero","$at",  "$v0",  "$v1",  "$a0",  "$a1",  "$a2",  "$a3",
      "$t0",  "$t1",  "$t2",  "$t3",  "$t4",  "$t5",  "$t6",  "$t7",
      "$s0",  "$s1",  "$s2",  "$s3",  "$s4",  "$s5",  "$s6",  "$s7",
      "$t8",  "$t9",  "$k0",  "$k1",  "$gp",  "$sp",  "$fp",  "$ra"
      );

meta
   begin
      comment         '!',
      isa_registers   float_registers | integer_registers | integer_register_alias

      #blockcomment       \/\* \*\/,
      end;

constant
   $a0     integer_register_alias["$a0"],
   $a1     integer_register_alias["$a1"],
   $a2     integer_register_alias["$a2"],
   $a3     integer_register_alias["$a3"],
   $sp     integer_register_alias["$sp"],
   $gp     integer_register_alias["$gp"],
   $ra     integer_register_alias["$ra"],
   $t9     integer_register_alias["$t9"],
   $f12    float_registers ["$f12"],
   $f13    float_registers ["$f13"],
   $f14    float_registers ["$f14"],
   $f15    float_registers ["$f15"],
   $CpC    float_registers ["$CpC"],

   f_tag_cpc 32;

constant
   iop_lui20         0,
   iop_lui16         1,
   #
   iop_oli16         0,
   iop_ali16         1,
   #
   iop_add16         0,
   iop_lli16         1,
   #
   iop_lls16         0,
   #
   iop_syscall       0,
   iop_break         1,
   #
   #
   branch_on_true    1,
   branch_on_false   0,
   #
   branch_on_greater 0,
   branch_on_leq     1,
   #
   _bltz             0,
   _bltzal           1,
   _bgez             0,
   _bgezal           1;

bitconstant
   nofnop       0 0 0,  #- No fusion no pam
   fusehead     0 0 1,  #- The instruction is a fuse head.
   widecons     0 1 0,  #- Wide consumer instruction fusing.
   condpam      0 1 1,  #- Conditional PAM instruction   : Instruction's dest may be used for memory access.
   uncondpam    1 0 0,  #- Unconditional PAM instruction : Instruction's dest will be used for memory access.
   dagdals      1 0 1;  #- Dagda Load or Store.

#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Type declarations define instruction fields as well as variables used in macro instructions.  #
#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#

type
   op0          constant       field          31   3,
   op1          constant       field          28   3,
   opcode       constant       field          31   6,
   rs           register       field          25   5,

   # The following fields are used by immediate instructions which are used to load a constant
   # literal to a given register. Two flavors are supported. 20 bit loading load-upper-immediate
   # loads the assembler temporary with a 20 bit constant left justified. 16 bit flavor is the
   # same except that it loads a 16 bit constant, same as the MIPS instruction.

   #- Long Immediate Format
   #
   # : 31      : 25              : 5    : 4   : 3       0
   # :---------: ----------------:------:-----:----------:
   # : op0 op1 :  immediate20    : f51  : iop : d1/d2/d3 :
   # :---------: ----------------:------:-----:----------:

   immediate20  integer        field          25  20,
   immediate16  integer        field          20  16,
   simmediate16 signed         field          20  16,
   f51          integer        field           5   1,  #- filler to align after a 20 bit constant.
   iop          constant       field           4   1,  #- Second opcode for immediate instructions.
   d1_d2_d3     integer        field           3   3,
   cf           constant       field           0   1,  #- This is a control-flow paradigm instruction.

   #- Short Immediate Format
   #
   # :31       : 25 : 20                : 4   : 3       0
   # ----------: ---:-------------------:-----:----------:
   # : op0 op1 : rs :    immediate16    : iop : d1/d2/d3 :
   # :---------: ---:-------------------:-----:----------:

   rt           register       field          20   5,
   rd           register       field          15   5,
   immediate7   integer        field          10   7,

   #- 3-Op Immediate Format
   #
   # :31       : 25 : 20 : 15 : 10            : 3       0
   # ----------: ---:----:----:---------------:----------:
   # : op0 op1 : rs : rt : rd : immediate7    : d1/d2/d3 :
   # :---------: ---:----:----:---------------:----------:


   d2_q         integer        field          20   2,
   uimmediate   integer        field          15  16,

   s_immediate  signed         field          15  12,
   us_immediate integer        field          15  12,
   j_offset     integer        field          28  25,

   cond         integer        field          25   5,

   copf2        integer        field          20   5,
   copf3        integer        field          10   7,
   tf           integer        field           4   1,

   ft           register       fixedfield     20   5,
   fs           register       fixedfield     15   5,
   fd           register       fixedfield     10   5,
   uccf         integer        field          10   3,    # unused zero field.
   ufzf         integer        field           7   2,    # unused zero field.
   ufc          integer        field           5   2,    # unused zero field.

   address      label          variable,
   address_bo   baseoffset     variable,

   rdest        register       variable,
   rsrc1        register       variable,
   rsrc2        register       variable,
   rsrc3        register       variable,
   src2         integer        variable,
   fsrc2        float          variable,
   tl           integer        temporary   32,
   tx           integer        temporary   16,
   ty           integer        temporary   16,
   tz           integer        temporary   32,
   l1           label          temporary;

attributes
     i_class       : float_class,
                     integer_class,
                     long_integer_class;    #- Multi-cycle integer ops.

     i_cycles      : single_cycle,
                     multiple_cycles;

     i_type        : alu_type,
                     branch_type_0,
                     branch_type_1,
                     branch_type_2,
                     load_type,
                     store_type;

     exu           : wait_memory,
                     load_unit,
                     store_unit,
                     integer_unit,
                     f_add_unit,
                     f_mul_unit;

     c_what        : condition_equal,
                     condition_gez,
                     condition_gtz,
                     condition_lez,
                     condition_ltz,
                     condition_neq,
                     condition_u,
                     condition_z;

     c_detail      : number_of_detail_types,
                     conditional_direct,
                     conditional_direct_link,
                     unconditional_direct,
                     unconditional_direct_link,
                     unconditional_indirect,
                     unconditional_indirect_link;

     dest_type     : float_register,integer_register,double_register,
                     special_input,
                     cpc_register,
                     lo_hi_register;

     l_dest_r      : integer;
     l_dest2_r     : integer;
     l_lop_r       : integer;
     l_lop2_r      : integer;
     l_rop_r       : integer;
     l_rop2_r      : integer;

     lop_type      : dest_type;
     rop_type      : dest_type;
     t_count       : general;        # Total instructions of this instruction.
     t_cycles      : general;        # Total cycles for this instruction.
     t_min         : general;        # Minimum cycles for this instruction.
     t_max         : general;        # Maximum cycles for this instruction.
end;


assertion
   #- All single cycle operations are executed by the integer unit.
   #

   1 : i_cycles  == single_cycle      : (exu == integer_unit)     ;


   #- If any operands of the instruction is integer, then it must be
   #  executed by either the integer unit or the load store unit.

   2 : (lop_type == integer_register) |
       (rop_type == integer_register) : (exu == integer_unit)      |
                                        (exu == load_unit)         |
                                        (exu == store_unit);
end;

integer
     cp_offset,
     cp_restoring;

procedure condition_code(x:32,y:32) untyped
begin
   if c_what == condition_equal then
      branch_input=(x == y)
   else
   if c_what == condition_gez then
      branch_input=((x.[31:1])==0)
   else
   if c_what == condition_gtz then
      branch_input=(x > 0)
   else
   if c_what == condition_lez then
      branch_input=(x.[31:1] | (x == 0))
   else
   if c_what == condition_ltz then
      branch_input=(x.[31:1])
   else
   if c_what == condition_neq then
      branch_input=(x ^= y)
   else
   if c_what == condition_u then
      begin
         branch_input=1;
         branch_target=x;
      end
   else
   if c_what == condition_z then
      begin
         branch_input=1;
      end;
end condition_code;


# These procedures are applied by the assembler to compute various
# offsets.
#
procedure add4(x) computation
begin
   add4=(x) + 4 ;
end add4;

procedure jump_address(x) computation
begin
   jump_address=x.[26:25];
end jump_address;

#- twelve_bit_constant/sixteen_bit_constant  - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#   Description.                                                                                 #
#      Returns true if the constant will fit into a 12 (16) bit field. Zero extension of this    #
#      field should yield the original value.                                                    #
#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#

procedure twelve_bit_constant(src:32) computation
begin
   if src.[31:20] == 0 then
      twelve_bit_constant=true
   else
      twelve_bit_constant=false;
end twelve_bit_constant;

procedure sixteen_bit_constant(src:32) computation
begin
   if (src.[31:16] == 0) then
      sixteen_bit_constant=true
   else
      sixteen_bit_constant=false;
end sixteen_bit_constant;

#- twelve_bit_signed_constant/sixteen_bit_signed_constant- - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#   Description.                                                                                 #
#      Returns true if the constant can be represented using a signed 12 (16) bit field. Sign    #
#      extension should yield the same 32 bit value.                                             #
#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#

procedure twelve_bit_signed_constant(src:32) computation
begin
   if (src.[31:20] == 0xfffff) & (src.[11:1] == 1) then
      twelve_bit_signed_constant=true
   else
   if (src.[31:21] == 0) then
      twelve_bit_signed_constant=true
   else
      twelve_bit_signed_constant=false;
end twelve_bit_signed_constant;

procedure sixteen_bit_signed_constant(src:32) computation
begin
   if (src.[31:16] == 0xffff) & (src.[15:1] == 1) then
      sixteen_bit_signed_constant=true
   else
   if (src.[31:17] == 0) then
      sixteen_bit_signed_constant=true
   else
      sixteen_bit_signed_constant=false;
end sixteen_bit_signed_constant;

procedure branch_address(x) computation
begin
   local txx;

   txx = x >> 2;
   if twelve_bit_signed_constant(txx) then
      branch_address=(x) >> 2
   else
      begin
         printf("\n\n@-1. -----------> branch address overflow: %d <--------------------\n\n",txx);
         branch_address=0;
      end;
end branch_address;

procedure branch_address16(x) computation
begin
   branch_address16=(x) >> 2;
end branch_address16;

#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
# Upperm, lowerc                                                                                 #
# --------------                                                                                 #
# These two functions are used to generate a pair of instructions to load a value from a given   #
# absolute address.                                                                              #
#                                                                                                #
# These two functions together break up a 32 bit value into two 16 bit values such that if the   #
# 16 bit value returned by upperm is loaded into a register using an lui instruction and that    #
# register is added to the 32-bit sign extended form of the 16 bit value returned by lowerc,     #
# the original 32 bit value is obtained. As a result, a value from a given absolute address can  #
# be loaded by using a lui to load the upperm result into the assembler temporary ($1) and       #
# supplying the lowerc value as the offset field of a load instruction which uses $1 as the      #
# base register.                                                                                 #
#                                                                                                #
# For this, we check the MSB of the lower half of the 32-bit value (i.e., bit 15. If this bit    #
# is one, when the lower part is sign extended to 32 bits, it will be expanded into 0xffffllll   #
# where 0xllll represents the lower 16 bits. Since the lower 16 bits of the lui'd value is       #
# zero, lower 16 bits will simply replace the lower 16 bits of the result, while 0xffff          #
# portion will decrement the upper 16 bits by one. By checking the "sign bit" of the lower       #
# half and adding it into the upper half, we can generate two 16 bit quantities which can        #
# be combined using an lui and sign-extended addition of the offset field.                       #
#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#

procedure upperm(x) computation
begin
   local lx;

   lx = x.[11:1];
   upperm=x.[31:20] + lx;
end upperm;

procedure lowerc(x) computation
begin
   lowerc=x.[11:12];
end lowerc;

procedure upper20(x) computation
begin
   upper20=x.[31:20];
end upper20;

procedure lower12(x) computation
begin
   lower12=x.[11:12];
end lower12;

# Utility procedures save on typing and eliminate some errors that
# would otherwise may result.
#
procedure sign_extend_24 (x:8)
begin
   sign_extend_24=(x.[7:1] |< 24) || x;
end sign_extend_24;

procedure sign_extend_16 (x:16)
begin
   sign_extend_16=(x.[15:1] |< 16) || x;
end sign_extend_16;

procedure sign_extend_16_branch (x:16)
begin
   sign_extend_16_branch=(x.[15:1] |< 14) || x ||  (0 |< 2);
end sign_extend_16_branch;

procedure zero_extend_16 (x:16)
begin
   zero_extend_16=x & 0xffff;
end zero_extend_16;

procedure zero_extend_12 (x:12)
begin
   zero_extend_12=x & 0xfff;
end zero_extend_12;

procedure sign_extend_12 (x:12)
begin
   sign_extend_12=(x.[11:1] |< 20) || x;
end sign_extend_12;

procedure sign_extend_12_branch (x:12)
begin
   sign_extend_12_branch=(x.[11:1] |< 18) || x ||  (0 |< 2);
end sign_extend_12_branch;


bitconstant         #- Co-processor op1 field.
   #
   _single_float    0 0 0,      #  s
   _double_float    0 0 1,      #  d
   _single_fixed    0 1 0,      #  w
   _mf              0 1 1,
   _cf              1 0 0,
   _mt              1 0 1,
   _ct              1 1 0,
   _bc              1 1 1,

   #
   _op0_cop  0 0 0, #- Does not have op1
   _op0_ml   0 0 1, #- Uses op1
   _op0_ms   0 1 0, #- Uses op1
   _op0_i    0 1 1, #- Uses op1
   _op0_ir   1 0 0, #- Uses op1
   _op0_ii   1 0 1, #- Uses op1
   _op0_j    1 1 0, #- Does not have op1
   _op0_jal  1 1 1, #- Does not have op1


   #- C-Format instructions           op0 = 000 (_op0_cop)
   #  -----------------------------------------------------
   #            28..26
   #            ------
   _cop1        0 0 0 ,    #- Coprocessor format


   #- M-Format instructions - Loads   op0 = 001 (_op0_ml)
   #  ---------------------------------------------------
   #            28..26
   #            ------
   _lb          0 0 0,    #- M format
   _lbu         0 0 1,    #- M format
   _lh          0 1 0,    #- M format
   _lhu         0 1 1,    #- M format
   _lw          1 0 0,    #- M format
   _lwc1        1 0 1,    #- M format
   _lwl         1 1 0,    #- M format
   _lwr         1 1 1,    #- M format

   #- M-Format instructions - Stores  op0 = 010 (_op0_ms)
   #  ---------------------------------------------------
   #            28..26
   #            ------
   _sb          0 0 0,    #- M format
   _sh          0 0 1,    #- M format
   _sw          0 1 0,    #- M format
   _swc1        0 1 1,    #- M format
   _swl         1 0 0,    #- M format
   _swr         1 0 1,    #- M format
   _bne         1 1 0,    #- M format
   _beq         1 1 1,    #- M format

   #- I-Format instructions           op0 = 011 (_op0_i)
   #  ---------------------------------------------------
   #            28..26
   #            ------
   _addi        0 0 0 ,    #- I format
   _addia       0 0 1 ,    #- I format # was unused. Set for inst splits.
   _addiu       0 1 0 ,    #- I format
   _andi        0 1 1 ,    #- I format
   _ori         1 0 0 ,    #- I format
   _slti        1 0 1 ,    #- I format
   _sltiu       1 1 0 ,    #- I format
   _xori        1 1 1 ,    #- I format


   #
   #- Immediate and R Format (group0) op0 = 100 (_op0_ir)
   #  -----------------------------------------------------
   #            28..26
   #            ------
   _ali         0 0 0 ,    #- Add lower immediate.
   _alis        0 0 1 ,    #- Add lower immediate signed.
   _lui         0 1 1 ,    #- Load Upper Immediate: 20/16 bit Long/short immediate format.
   _oli         1 0 0 ,    #- OR Lower Immediate  : 16 bit short immediate format.
   _syscall     1 0 1 ,    #- Long immediate (20 bit) format.
   _sra         1 1 0 ,    #-
   _unused      0 1 0 ,    #- Long immediate (20 bit) format.
   _unused_2    1 1 1 ,    #-

   #
   #- Immediate and R Format (group1) op0 = 101 (_op0_ii)
   #  -----------------------------------------------------
   #            28..26
   #            ------
   _r_type      0 0 0 ,    #-
   _sll         0 0 1 ,    #- R format
   _srl         0 1 0 ,    #- R format

   _bcond0      0 1 1 ,    #- B format
   _bcond1      1 0 0 ,    #- B format
   _bgtz        1 0 1 ,    #- B format
   _bift        1 1 0 ,    #- Branch if true.

   _unused2     1 1 1 ,    #-


   #- R-Format instructions immediate7 field
   #  -----------------------------------------------------

   _add         0 0 0   0 0 0 0 ,    #- R format
   _addu        0 0 0   0 0 0 1 ,    #- R format
   _and         0 0 0   0 0 1 0 ,    #- R format
   _div         0 0 0   0 0 1 1 ,    #- R format
   _divu        0 0 0   0 1 0 0 ,    #- R format
   _jalr        0 0 0   0 1 0 1 ,    #- R format
   _jr          0 0 0   0 1 1 0 ,    #- R format
   _mfhi        0 0 0   0 1 1 1 ,    #- R format
   _mflo        0 0 0   1 0 0 0 ,    #- R format
   _mtlo        0 0 0   1 0 0 1 ,    #- R format
   _mult        0 0 0   1 0 1 0 ,    #- R format
   _multu       0 0 0   1 0 1 1 ,    #- R format
   _nor         0 0 0   1 1 0 0 ,    #- R format
   _or          0 0 0   1 1 0 1 ,    #- R format
   _seq         0 0 0   1 1 1 0 ,    #- R format
   _sllv        0 0 0   1 1 1 1 ,    #- R format
   _slt         0 0 1   0 0 0 0 ,    #- R format
   _sltu        0 0 1   0 0 0 1 ,    #- R format
   _srav        0 0 1   0 0 1 0 ,    #- R format
   _srlv        0 0 1   0 0 1 1 ,    #- R format
   _sub         0 0 1   0 1 0 0 ,    #- R format
   _subu        0 0 1   0 1 0 1 ,    #- R format
   _xor         0 0 1   0 1 1 0 ,    #- R format



   # Copf2 field.
   #
   # This field extends 20..16 and used by coprocessor instructions.
   #
   # Bits:   20 19 18 17 16
   #         --------------
   _f        0 0 0  0  0  0 ,
   _t        0 0 0  0  0  1 ,

   # Cop0
   # -----
   # Co processor0 operations.
   #
   # Bits :  4 3  2 1 0
   #         ---  -----

   _tlbp     0 1  0 0 0 ,
   _rfe      1 0  0 0 0 ,
   _tlbr     0 0  0 0 1 ,
   _tlbwi    0 0  0 1 0 ,
   _tlbwr    0 0  1 1 0 ,

   _zero     0 0 0  0 0 0 ;

#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
# Floating point compares. Each predicate and its negation                                       #
# use the same cond bits.                                                                        #
#- - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#

bitconstant
   _fcond_f     0 0 0 0,  # False / True.
   _fcond_un    0 0 0 1,  # Unordered/ordered (OR)
   _fcond_eq    0 0 1 0,  # Equal / Not equal (NEQ)
   _fcond_ueq   0 0 1 1,  # Unordered or equal /
   _fcond_olt   0 1 0 0,  # Ordered or less than /
                          # Unordered or greater than or equal (UGE)
   _fcond_ult   0 1 0 1,  # Unordered or less than /
                          # Ordered or greater than or equal (OGE)
   _fcond_ole   0 1 1 0,  # Ordered or less than or equal /
                          # Unordered or greater than (UGT)
   _fcond_ule   0 1 1 1,  # Unordered or less than or equal /
                          # Ordered or greater than (OGT)
   _fcond_sf    1 0 0 0,  # Signaling false / Signaling true (ST)
   _fcond_ngle  1 0 0 1,  # Not greater than or less than or equal /
                          # Greater than or less than or equal (GLE)
   _fcond_seq   1 0 1 0,  # Signaling equal / Signaling not equal (SNE)
   _fcond_ngl   1 0 1 1,  # NOt greater or less than /
                          # Greater than or less than (GL)
   _fcond_lt    1 1 0 0,  # Less than / Not less than (NLT)
   _fcond_nge   1 1 0 1,  # Not greater than or equal /
                          # Greater than or equal (GE)
   _fcond_le    1 1 1 0,  # Less than or equal / Not less than or equal (NLE)
   _fcond_ngt   1 1 1 1;  # Not greater than / Greater than (GT)

bitconstant
   _add_fmt     0 0 0 0,
   _sub_fmt     0 0 0 1,
   _mul_fmt     0 0 1 0,
   _div_fmt     0 0 1 1,
   _abs_fmt     0 1 0 1,
   _mov_fmt     0 1 1 0,
   _neg_fmt     0 1 1 1,
   _cvt_s_fmt   0 0 0 0,    # 32,
   _cvt_d_fmt   0 0 0 1,    # 33,
   _cvt_w_fmt   0 1 0 0,    # 36,
   _c_fmt       0 0 0 0,
   _trunc_w     1 1 0 1;

bitconstant
   fc_arithmetic  0 0,
   fc_cvt         1 0,    # 33,
   fc_c_fmt       1 1;

bitconstant
   _fmul        0 0 1 0,
   _fdiv        1 0 1 0,
   _fadd        1 0 0 0,
   _fsub        0 0 0 1,
   _fneg        0 1 1 1;

integer
   syscall_counter;

instruction

#- LUI20__ : Load upper immediate 20 bit constant - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  This instruction has an implicit destination register of $1.                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lui20__ immediate20 d1_d2_d3
         emit op0=_op0_ir op1=_lui immediate20 f51=0 iop=iop_lui20 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,   i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,            c_detail  :none,              dest_type :integer_register,
              lop_type :none,            rop_type  :none,              i_type    :alu_type,
              l_dest_r :1,               l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r :none,            l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_EX
                  dest=immediate20 || 0 |< 12;
            end;
         end,

   lui16__ rs immediate16 d1_d2_d3
         emit op0=_op0_ir op1=_lui rs immediate16 iop=iop_lui16 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,   i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,            c_detail  :none,              dest_type :integer_register,
              lop_type :none,            rop_type  :none,              i_type    :alu_type,
              l_dest_r :rs,              l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r :none,            l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_EX
                  dest=immediate16 || 0 |< 16;
            end;
         end,

#- OLI16__ : Or Lower Immediate 16 bit - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  This instruction immediate ORs its destination register with a 16 bit immediate and writes    #
#  back to its destination register. RS serves both as the source and the destination for this   #
#  instruction.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   oli16__ rs immediate16 d1_d2_d3
         emit op0=_op0_ir op1=_oli rs immediate16 iop=iop_oli16 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,    i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,             c_detail  :none,              dest_type :integer_register,
              lop_type :integer_register, rop_type  :none,              i_type    :alu_type,
              l_dest_r :rs,               l_dest2_r :none,              l_lop_r   :rs,
              l_lop2_r :none,             l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_ID
                  zimm=immediate16 & 0xffff;
            end;

            exact s_EX
                  dest=lop | zimm;
            end;
         end,

#- ALI16__ : And Lower Immediate 16 bit - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  This instruction immediate ANDs its destination register with a 16 bit immediate and writes   #
#  back to its destination register. RS serves both as the source and the destination for this   #
#  instruction.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   ali16__ rs immediate16 d1_d2_d3
         emit op0=_op0_ir op1=_oli rs immediate16 iop=iop_ali16 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,     i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,              c_detail  :none,              dest_type :integer_register,
              lop_type :integer_register,  rop_type  :none,              i_type    :alu_type,
              l_dest_r :rs,                l_dest2_r :none,              l_lop_r   :rs,
              l_lop2_r :none,              l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_ID
                  zimm=immediate16 & 0xffff;
            end;

            exact s_EX
                  dest=lop & zimm;
            end;
         end,

#- ADD16__ : Add Lower Immediate 16 bit - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  This instruction adds the 16 bit immediate to its source register and writes the result to    #
#  register one.                                                                                 #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   add16__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ir op1=_ali rs simmediate16 iop=iop_add16 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,     i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,              c_detail  :none,              dest_type :integer_register,
              lop_type :integer_register,  rop_type  :none,              i_type    :alu_type,
              l_dest_r :1,                 l_dest2_r :none,              l_lop_r   :rs,
              l_lop2_r :none,              l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_ID
                  simm=sign_extend_16(simmediate16);
            end;

            exact s_EX
                  dest=lop + simm;
            end;
         end,

#- LLI16__ : Load Lower Immediate 16 bit - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  This instruction loads a 16 bit immediate to its destination register and clears its upper    #
#  bits.                                                                                         #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lli16__ rs immediate16 d1_d2_d3
         emit op0=_op0_ir op1=_ali rs immediate16 iop=iop_lli16 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,   i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,            c_detail  :none,              dest_type :integer_register,
              lop_type :none,            rop_type  :none,              i_type    :alu_type,
              l_dest_r :rs,              l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r :none,            l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_ID
                  zimm=zero_extend_16(immediate16);
            end;

            exact s_EX
                  dest=zimm;
            end;
         end,

#- LLS16__ : Load Lower Signed Immediate 16 bit - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  This instruction loads a 16 bit immediate to its destination register and sign-extends it.    #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lls16__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ir op1=_alis rs simmediate16 iop=iop_lli16 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,   i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,            c_detail  :none,              dest_type :integer_register,
              lop_type :none,            rop_type  :none,              i_type    :alu_type,
              l_dest_r :rs,              l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r :none,            l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_ID
                  simm=sign_extend_16(simmediate16);
            end;

            exact s_EX
                  dest=simm;
            end;
         end,

#- BNE : Branch on not equal - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Branch if the source operand is true.                                                         #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   bne__ rs rt s_immediate d1_d2_d3
        emit op0=_op0_ms op1=_bne rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_neq,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : branch_type_0,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             ),


   bne__ rs rt address d1_d2_d3
        emit op0=_op0_ms op1=_bne rs rt s_immediate=<address.delta.branch_address> d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_neq,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : branch_type_0,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             ),

#- BEQ : branch on equal - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Branch if the source operand is true.                                                         #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   beq__ rs rt s_immediate d1_d2_d3
         emit op0=_op0_ms op1=_beq rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_equal,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : branch_type_0,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             ),

#- BIFT__ : Branch if true - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Branch if the source operand is true.                                                         #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   bift__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bift rs simmediate16 iop=branch_on_true d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_neq,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : 0,
              l_rop2_r  : none
             ),

   bift rsrc1 address macro
         begin
            bift__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=0;
         end,

#- BIFF__ : Branch if false- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Branch if the source operand is false.                                                        #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   biff__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bift rs simmediate16 iop=branch_on_false d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_equal,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : 0,
              l_rop2_r  : none
             ),

   biff rsrc1 address macro
         begin
            biff__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,

#- BGTZ__ : Branch on greater than zero - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  MIPS I.                                                                                       #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   bgtz__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bgtz rs simmediate16 iop=branch_on_greater d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_gtz,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             ),

   bgtz rsrc1 address macro
         begin
            bgtz__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,


#- BLEZ : Branch on less than or equal to zero  - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  MIPS I.                                                                                       #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   blez__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bgtz rs simmediate16 iop=branch_on_leq d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_lez,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             ),

   blez rsrc1 address macro
         begin
            blez__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,


#- BLTZ__ : Branch on less than zero  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  MIPS I.                                                                                       #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   bltz__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bcond0 rs simmediate16 iop=_bltz d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_ltz,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             ),

   bltz rsrc1 address macro
         begin
            bltz__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,


#- BLTZAL__ : Branch on less zero and link - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  MIPS I.                                                                                       #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   bltzal__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bcond0 rs simmediate16 iop=_bltzal d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_ltz,
              c_detail  : conditional_direct_link,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : 31,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_EX
                  dest=my_pc + 4;
            end;
         end,

   bltzal rsrc1 address macro
         begin
            bltzal__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,


#- BGEZ__ : Branch on greater than or equal to zero - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  MIPS I.                                                                                       #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   bgez__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bcond1 rs simmediate16 iop=_bgez d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_gez,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             ),

   bgez rsrc1 address macro
        begin
           bgez__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,


#- BGEZAL__ : Branch on greater than or equal to zero and link  - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  MIPS I.                                                                                       #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   bgezal__ rs simmediate16 d1_d2_d3
         emit op0=_op0_ii op1=_bcond1 rs simmediate16 iop=_bgezal d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_gez,
              c_detail  : conditional_direct_link,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : 31,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_EX
                  dest=my_pc + 4;
            end;
         end,

   bgezal rsrc1 address macro
         begin
            bgezal__ : rs=rsrc1 simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,


#- SYSCALL__ : System call - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  This instruction is used to simulate external calls as if it is a single instruction. This    #
#  instruction uses $4 as its left operand and returns the result in $2.                         #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   syscall__ immediate20 d1_d2_d3
         emit op0=_op0_ir op1=_syscall immediate20 f51=0 iop=iop_syscall d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,   i_cycles  :multiple_cycles,   exu       :integer_unit,
              c_what   :none,            c_detail  :none,              dest_type :special_input,
              lop_type :special_input,   rop_type  :special_input,     i_type    :alu_type,
              l_dest_r :2,               l_dest2_r :7,                 l_lop_r   :2,
              l_lop2_r :4,               l_rop_r   :5,                 l_rop2_r  :6
             )
         begin
            exact s_id
                  syscall_counter = 0;
            end;
            exact s_ex
                  {dest,dest2}=builtin do_mips_syscall(lop,lop2,rop,rop2,0);
            end;
         end,


   syscall macro
         begin
            syscall__ : immediate20=0 d1_d2_d3=nofnop;
         end,

   syscall src2 macro
         begin
            syscall__ : immediate20=src2 d1_d2_d3=nofnop;
         end,

#- BREAK__ : Breakpoint - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#  We should list any variations of instructions with a constant field after the main            #
#  instruction so that the decoder will correctly print out the decoded instruction. For         #
#  example, the parameterless variant of the break instruction sets the code field to zero.      #
#  By putting the one with the parameter first we make sure that its representation goes to the  #
#  decoder.                                                                                      #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   break__ immediate20 d1_d2_d3
         emit op0=_op0_ir op1=_syscall immediate20 f51=0 iop=iop_break  d1_d2_d3 cf=1
         attributes
             (
              i_class  : integer_class,   i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   : none,            c_detail  :none,              dest_type :none,
              lop_type : none,            rop_type  :none,              i_type    :alu_type,
              l_dest_r : none,            l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r : none,            l_rop_r   :none,              l_rop2_r  :none
             ),

   break macro
         begin
            break__ : immediate20=0 d1_d2_d3=nofnop;
         end,


   break src2 macro
         begin
            break__ : immediate20=src2 d1_d2_d3=nofnop;
         end,

#- SLLV__: Shift word left logical variable- - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sllv__  rd rt rs d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_sllv d1_d2_d3 cf=1
     attributes
         (
          i_class   : integer_class,
          i_cycles  : single_cycle,
          exu       : integer_unit,
          c_what    : none,
          c_detail  : none,
          dest_type : integer_register,
          lop_type  : integer_register,
          rop_type  : integer_register,
          i_type    : alu_type,
          l_dest_r  : rd,
          l_dest2_r : none,
          l_lop_r   : rs,
          l_lop2_r  : none,
          l_rop_r   : rt,
          l_rop2_r  : none
         )
     begin
        exact s_EX
              dest=(+rop) << (lop.[4:5]);
        end;
     end,

   sllv rdest rsrc1 rsrc2 macro
         begin
            sllv__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,


#- SLL__ : Shift word left logical  - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sll__ rd rt immediate7 d1_d2_d3
         emit op0=_op0_ii op1=_sll rs=0 rt rd immediate7 d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,    i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,             c_detail  :none,              dest_type :integer_register,
              lop_type :none,             rop_type  :integer_register,  i_type    :alu_type,
              l_dest_r :rd,               l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r :none,             l_rop_r   :rt,                l_rop2_r  :none
             )
         begin
            exact s_EX
                  dest=(+rop) << (+immediate7);
            end;
         end,

   sll rdest rsrc1 src2 macro
         begin
            sll__: rd=rdest rt=rsrc1 immediate7=src2 d1_d2_d3=nofnop;
         end,

   sll rdest rsrc1 rsrc2 macro
         begin
            sllv__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,


#- ADD__ : Add word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   add__ rd rs rt d1_d2_d3
         emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_add d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :rd,                l_dest2_r:none,              l_lop_r  :rs,
              l_lop2_r :none,              l_rop_r  :rt,                l_rop2_r :none
             )
         begin
            exact s_EX
                  dest=lop + rop;
            end;
         end,

   add rdest rsrc1 rsrc2 macro
         begin
            add__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- ADDU__ : Add unsigned word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   addu__ rd rs rt d1_d2_d3
        emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_addu d1_d2_d3 cf=1
        attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :rd,                l_dest2_r:none,              l_lop_r  :rs,
              l_lop2_r :none,              l_rop_r  :rt,                l_rop2_r :none
             )
         begin
            exact s_EX
                  dest=lop + rop;
            end;
         end,

   addu rdest rsrc1 rsrc2 macro
         begin
            addu__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- AND__ : And - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   and__ rd rs rt d1_d2_d3
       emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_and d1_d2_d3 cf=1
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :rd,                l_dest2_r:none,              l_lop_r  :rs,
              l_lop2_r :none,              l_rop_r  :rt,                l_rop2_r :none
             )
         begin
            exact s_EX
                  dest=lop & rop;
            end;
         end,

   and rdest rsrc1 rsrc2 macro
         begin
            and__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- MFLO__: Move from LO register  - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#     For locking purposes we pretend that both hi and lo are read.                              #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   mflo__ rd d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs=0 rt=0 rd immediate7=_mflo d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,           i_cycles :single_cycle,   exu      :integer_unit,
      c_what   :none,                    c_detail :none,           dest_type:integer_register,
      lop_type :lo_hi_register,          rop_type :none,           i_type   :alu_type,
      l_dest_r :rd,                      l_dest2_r:none,           l_lop_r  :lo_hi_register_number,
      l_lop2_r :lo_hi_register_number+1, l_rop_r  :none,           l_rop2_r :none
     )
     begin
        exact s_ex
              if rd == 0 then
                 dest = 0
              else
                 dest=lop2;
         end;
     end,

   mflo rdest macro
        begin
           inline "mflo__  $%d,%d" rdest,nofnop;
        end,

   mul rdest rsrc1 src2 macro
       begin
          inline "li    $1,%d" src2;
          inline "multu__ $%d,$%d,%d" rsrc1,1,nofnop;
          inline "mflo__  $%d,%d" rdest,nofnop;
       end,

   mul rdest rsrc1 rsrc2 macro
       begin
          inline "multu__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
          inline "mflo__  $%d,%d" rdest,nofnop;
       end,


#- DIV__ : Divide- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   div__ rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd=0 immediate7=_div d1_d2_d3 cf=1
     attributes
     (
      i_class  :long_integer_class,    i_cycles :multiple_cycles,         exu      :integer_unit,
      c_what   :none,                  c_detail :none,                    dest_type:lo_hi_register,
      lop_type :integer_register,      rop_type :integer_register,        i_type   :alu_type,
      l_dest_r :lo_hi_register_number, l_dest2_r:lo_hi_register_number+1, l_lop_r  :rs,
      l_lop2_r :none,                  l_rop_r  :rt,                      l_rop2_r :none
     )
     begin
        exact s_ID
              latency 7; # was 32;
        end;

        exact s_EX
              if rop == 0 then
                 exception = 1
              else
                begin
                    dest2 = lop / rop;
                    dest  = lop % rop;
                end;
         end;
     end,

   div  rsrc1 rsrc2 macro
           begin
              inline "		div__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
           end,

   div  rdest rsrc1 rsrc2 macro
           begin
              inline "		div__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
              inline "		mflo__ $%d,%d" rdest,nofnop;

              #if reorder then
              #   begin
              #      if rdest == 0 then printf("_______________ LEAK __________________\n");
              #      inline "		bne__ $%d,$0,$UPFAST_X_%d,%d" rsrc2,linenumber,nofnop;
              #      inline "		break__ 7,%d" nofnop;
              #      inline "$UPFAST_X_%d:	" linenumber;
              #      inline "		div__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
              #      inline "		mflo__ $%d,%d" rdest,nofnop;
              #   end;
              #trace;
           end,

            # div__  : rs=rsrc1  rt=rsrc2 d1_d2_d3=nofnop;
            # mflo__ : rd=rdest d1_d2_d3=nofnop;
            # makelabel(l1);
            # bne  : rs=rsrc2 rt=0 address=l1;
            # break__: immediate20=7 d1_d2_d3=nofnop;
            # l1:;

   div  rdest rsrc1 src2 macro
         begin
            if pass1 == 0 then
               begin
                  inline "	li   $%d,%d" rdest,src2;
                  inline "	bift  $%d,$UPFAST_S_%d" rdest,linenumber;
                  inline "	break__ 7,%d" nofnop;
                  inline "$UPFAST_S_%d:	" linenumber;
                  inline "  	div__  $%d,$%d,%d" rsrc1,rdest,nofnop;
                  inline "	mflo__ $%d,%d" rdest,nofnop;
               end;

            # addiu: rt=rdest rs=0 uimmediate=src2;
            # div__  : rs=rsrc1 rt=rdest d1_d2_d3=nofnop;
            # makelabel(l1);
            # bne  : rs=rdest rt=0 address=l1;
            # mflo__ : rd=rdest d1_d2_d3=nofnop;
            # break__: immediate20=7 d1_d2_d3=nofnop;
            # l1:;
         end,


#- DIVU__ : Divide - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   divu__ rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd=0 immediate7=_divu d1_d2_d3 cf=1
     attributes
     (
      i_class  :long_integer_class,    i_cycles :multiple_cycles,         exu      :integer_unit,
      c_what   :none,                  c_detail :none,                    dest_type:lo_hi_register,
      lop_type :integer_register,      rop_type :integer_register,        i_type   :alu_type,
      l_dest_r :lo_hi_register_number, l_dest2_r:lo_hi_register_number+1, l_lop_r  :rs,
      l_lop2_r :none,                  l_rop_r  :rt,                      l_rop2_r :none
     )
     begin
        exact s_ID
              latency 7; # was 32;
        end;

        exact s_EX
              if rop == 0 then
                 exception = 1
              else
                 begin
                    dest2  =(+ lop) / (+ rop);
                    dest   =(+ lop) % (+ rop);
                 end;
        end;
     end,

   divu  rsrc1 rsrc2 macro
           begin
              inline "		divu__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
           end,

   divu rdest rsrc1 rsrc2 macro
         begin
            if (pass1 == 0)  & reorder then
               begin
                  inline "	bift  $%d,$UPFAST_S_%d" rsrc2,linenumber;
                  inline "	break__ 7,%d" nofnop;
                  inline "$UPFAST_S_%d:	" linenumber;
                  inline "	divu__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
                  inline "	mflo__ $%d,%d" rdest,nofnop;
               end
            else
            if (pass1 == 0)  then
               begin
                  inline "	divu__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
               end;

            # divu__ : rs=rsrc1  rt=rsrc2 d1_d2_d3=nofnop;
            # mflo__ : rd=rdest d1_d2_d3=nofnop;
            # makelabel(l1);
            # bne  : rs=rsrc2 rt=0 address=l1;
            # break__: immediate20=7 d1_d2_d3=nofnop;
            # l1:;
         end,

   divu rdest rsrc1 src2 macro
         begin
            if pass1 == 0 then
               begin
                  inline "	li   $%d,%d" rdest,src2;
                  inline "	bift $%d,$UPFAST_S_%d" rdest,linenumber;
                  inline "	break__ 7,%d" nofnop;
                  inline "$UPFAST_S_%d:	" linenumber;
                  inline "  	div__  $%d,$%d,%d" rsrc1,rdest,nofnop;
                  inline "	mflo__ $%d,%d" rdest,nofnop;
               end;

            # addiu: rt=rdest rs=0 uimmediate=src2;
            # divu__ : rs=rsrc1 rt=rdest d1_d2_d3=nofnop;
            # makelabel(l1);
            # bne  : rs=rdest rt=0 address=l1;
            # mflo__ : rd=rdest d1_d2_d3=nofnop;
            # break__: immediate20=7 d1_d2_d3=nofnop;
            # l1:;
         end,

#- JALR : Jump and link register - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   jalr__ rd rs d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt=0 rd immediate7=_jalr d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,     i_cycles :single_cycle,               exu      :integer_unit,
      c_what   :condition_u,       c_detail :unconditional_direct_link,  dest_type:integer_register,
      lop_type :integer_register,  rop_type :none,                       i_type   :branch_type_1,
      l_dest_r :rd,                l_dest2_r:none,                       l_lop_r  :rs,
      l_lop2_r :none,              l_rop_r  :none,                       l_rop2_r :none
     )
     begin
        exact s_EX
              dest=my_pc + 4;
              history branch_target : dest;
        end;
     end,

   jal rdest rsrc1 macro
         begin
            jalr__ : rd=rdest rs=rsrc1 d1_d2_d3=nofnop;
         end,

   jalr rsrc1 macro
         begin
            jalr__ : rd=31 rs=rsrc1 d1_d2_d3=nofnop;
         end,

   jal rsrc1 macro
         begin
            jalr__ : rd=31 rs=rsrc1 d1_d2_d3=nofnop;
         end,

   jalr rdest rsrc1 macro
         begin
            jalr__ : rd=rdest rs=rsrc1 d1_d2_d3=nofnop;
         end,


#- JR : Jump register - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   jr__ rs d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt=0 rd=0 immediate7=_jr d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,     i_cycles  : single_cycle,             exu       : integer_unit,
      c_what   :condition_u,       c_detail  : unconditional_indirect,   dest_type : none,
      lop_type :integer_register,  rop_type  : none,                     i_type    : branch_type_0,
      l_dest_r :none,              l_dest2_r : none,                     l_lop_r   : rs,
      l_lop2_r :none,              l_rop_r   : none,                     l_rop2_r  : none
     )
     begin
        exact s_EX
              if (rs == 31) then #  & (monitor > 0) then
                 history lop;
        end;
     end,

   j rdest macro
         begin
            jr__ : rs=rdest d1_d2_d3=nofnop;
         end,

   jr rdest macro
         begin
            jr__ : rs=rdest d1_d2_d3=nofnop;
         end,


#- MFHI__: Move from HI register  - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#     For locking purposes we pretend that both hi and lo are read.                              #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   mfhi__ rd d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs=0 rt=0 rd immediate7=_mfhi d1_d2_d3 cf=1
     attributes
     (
      i_class :integer_class,            i_cycles :single_cycle,   exu      :integer_unit,
      c_what  :none,                     c_detail :none,           dest_type:integer_register,
      lop_type:lo_hi_register,           rop_type :none,           i_type   :alu_type,
      l_dest_r:rd,                       l_dest2_r:none,           l_lop_r  :lo_hi_register_number,
      l_lop2_r:lo_hi_register_number+1,  l_rop_r  :none,           l_rop2_r :none
     )
     begin
        exact s_EX
              dest=lop;
        end;
     end,

   mfhi rdest macro
        begin
           inline "mfhi__  $%d,%d" rdest,nofnop;
        end,

   rem  rdest rsrc1 rsrc2 macro
        begin
           div__  : rs=rsrc1  rt=rsrc2 d1_d2_d3=nofnop;
           mfhi__ : rd=rdest d1_d2_d3=nofnop;
        end,

   rem rdest rsrc1 src2 macro
        begin
           inline "li $1,%d" src2;
           inline "div__ $%d,$1,%d" rsrc1,nofnop;
           inline "mfhi__ $%d,%d" rdest,nofnop;
        end,

   remu rdest rsrc1 rsrc2 macro
        begin
           divu__ : rs=rsrc1  rt=rsrc2 d1_d2_d3=nofnop;
           mfhi__ : rd=rdest d1_d2_d3=nofnop;
        end,


#- MTLO__: Move to LO register  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   mtlo__ rs d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt=0 rd=0 immediate7=_mtlo d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,              i_cycles :single_cycle,   exu      :integer_unit,
      c_what   :none,                       c_detail :none,           dest_type:lo_hi_register,
      lop_type :integer_register,           rop_type :none,           i_type   :alu_type,
      l_dest_r :lo_hi_register_number+1,    l_dest2_r:none,           l_lop_r  :rs,
      l_lop2_r :none,                       l_rop_r  :none,           l_rop2_r :none
     )
     begin
        exact s_ex
              dest=lop;
        end;
     end,

   mtlo rdest macro
        begin
           inline "mtlo__  $%d,%d" rdest,nofnop;
        end,

#- MULT__: Multiply word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   mult__ rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd=0 immediate7=_mult d1_d2_d3 cf=1
     attributes
     (
      i_class  :long_integer_class,    i_cycles :multiple_cycles,          exu      :integer_unit,
      c_what   :none,                  c_detail :none,                     dest_type:lo_hi_register,
      lop_type :integer_register,      rop_type :integer_register,         i_type   :alu_type,
      l_dest_r :lo_hi_register_number, l_dest2_r:lo_hi_register_number+1,  l_lop_r  :rs,
      l_lop2_r :none,                  l_rop_r  :rt,                       l_rop2_r :none
     )
     begin
        exact s_ID
              latency 3;
        end;

        exact s_EX
              builtin long_signed_multiply(lop,rop,hi_val,lo_val);
              dest=hi_val;
              dest2=lo_val;
        end;
     end,

   mult rsrc1 rsrc2 macro
       begin
          inline "	mult__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
       end,

#- MULTU__ : Multiply unsigned word- - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   multu__ rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd=0 immediate7=_multu d1_d2_d3 cf=1
     attributes
     (
      i_class   : long_integer_class,
      i_cycles  : multiple_cycles,
      exu       : integer_unit,
      c_what    : none,
      c_detail  : none,
      dest_type : lo_hi_register,
      lop_type  : integer_register,
      rop_type  : integer_register,
      i_type    : alu_type,
      l_dest_r  : lo_hi_register_number,
      l_dest2_r : lo_hi_register_number+1,
      l_lop_r   : rs,
      l_lop2_r  : none,
      l_rop_r   : rt,
      l_rop2_r  : none
     )
     begin
        exact s_ID
              latency 3;  # was 4
        end;

        exact s_EX
              builtin long_multiply(lop,rop,hi_val,lo_val);
              dest=hi_val;
              dest2=lo_val;
        end;
     end,

   multu rsrc1 rsrc2 macro
       begin
          inline "	multu__ $%d,$%d,%d" rsrc1,rsrc2,nofnop;
       end,

#- NOR__ : Not or - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   nor__ rd rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_nor d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,       i_cycles :single_cycle,          exu      :integer_unit,
      c_what   :none,                c_detail :none,                  dest_type:integer_register,
      lop_type :integer_register,    rop_type :integer_register,      i_type   :alu_type,
      l_dest_r :rd,                  l_dest2_r:none,                  l_lop_r  :rs,
      l_lop2_r :none,                l_rop_r  :rt,                    l_rop2_r :none
     )
     begin
        exact s_EX
              dest=(lop | rop) ^ 0xffffffff;
        end;
     end,

   nor rdest rsrc1 rsrc2 macro
         begin
            nor__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

   not  rsrc1 rsrc2 macro
        begin
           inline "nor__ $%d,$%d,$0,%d" rsrc1,rsrc2,nofnop;
        end,

#- ORI__ : Or Immediate - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   ori__ rt rs us_immediate d1_d2_d3
     emit op0=_op0_i op1=_ori rs rt us_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class   : integer_class,          i_cycles  : single_cycle,     exu       : integer_unit,
      c_what    : none,                   c_detail  : none,             dest_type : integer_register,
      lop_type  : integer_register,       rop_type  : none,             i_type    : alu_type,
      l_dest_r  : rt,                     l_dest2_r : none,             l_lop_r   : rs,
      l_lop2_r  : none,                   l_rop_r   : none,             l_rop2_r  : none
     )
     begin
        exact s_ID
              zimm=zero_extend_12(us_immediate);
        end;

        exact s_EX
              dest=lop | zimm;
        end;
     end,

   ori rsrc1 rsrc2 src2 macro
     begin
        if pass1 == 0 then
           begin
              if twelve_bit_constant(src2) then
                 inline "	ori__ $%d,$%d,%d,%d" rsrc1,rsrc2,src2,nofnop
              else
              if sixteen_bit_constant(src2) & (rsrc1 == rsrc2) then
                 begin
                    #printf("\n\n@-11. 16bc: constant (ori) oli16__ generated: %08x\n\n ",src2);
                    inline "	oli16__ $%d,%d,%d" rsrc1,src2,nofnop;
                 end
              else
              if sixteen_bit_constant(src2) then
                 begin
                    inline "	lli16__ $%d,%d,%d" rsrc1, src2,nofnop;
                    inline "	or__ $%d,$%d,$%d,%d" rsrc1,rsrc1,rsrc2,nofnop;
                 end
              else
                 begin
                    printf("\n\n@-12. long: constant : %08x :",src2);
                    printf("rsrc1=%d rsrc2=%d\n\n",rsrc1,rsrc2);
                    inline "	lui20__ %d,%d" src2.[31:20],nofnop;
                    inline "	ori__  $1,$1,%d,%d" src2.[11:12],nofnop;
                    inline "	or__ $%d,$%d,$1,%d" rsrc1,rsrc2,nofnop;
                 end;
           end;
     end,

#- OR__ : Or - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   or__  rd rs rt d1_d2_d3
      emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_or d1_d2_d3 cf=1
      attributes
      (
       i_class :integer_class,       i_cycles :single_cycle,         exu      :integer_unit,
       c_what  :none,                c_detail :none,                 dest_type:integer_register,
       lop_type:integer_register,    rop_type :integer_register,     i_type   :alu_type,
       l_dest_r:rd,                  l_dest2_r:none,                 l_lop_r  :rs,
       l_lop2_r:none,                l_rop_r  :rt,                   l_rop2_r :none
      )
      begin
         exact s_EX
               dest=lop | rop;
         end;
      end,

   or rdest rsrc1 rsrc2 macro
         begin
            or__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

   or rsrc1 rsrc2 src2 macro
      begin
         if (src2 < 0x4000) & (src2 > 0) then
            inline "ori__ $%d,$%d,%d,%d" rsrc1,rsrc2,src2,nofnop
         else
            begin
               inline "li $1,%d" src2;
               inline "or__ $%d,$%d,$1,%d" rsrc1,rsrc2,nofnop;
            end;
      end,

#- XOR__: Exclusive Or - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   xor__  rd rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_xor d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,      i_cycles :single_cycle,           exu      :integer_unit,
      c_what   :none,               c_detail :none,                   dest_type:integer_register,
      lop_type :integer_register,   rop_type :integer_register,       i_type   :alu_type,
      l_dest_r :rd,                 l_dest2_r:none,                   l_lop_r  :rs,
      l_lop2_r :none,               l_rop_r  :rt,                     l_rop2_r :none
     )
     begin
        exact s_EX
              dest=lop ^ rop;
        end;
     end,

   xor rdest rsrc1 rsrc2 macro
         begin
            xor__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- SLT__ : Set on Less than - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   slt__ rd rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_slt d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,       i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,    rop_type :integer_register,     i_type   :alu_type,
      l_dest_r :rd,                  l_dest2_r:none,                 l_lop_r  :rs,
      l_lop2_r :none,                l_rop_r  :rt,                   l_rop2_r :none
     )
     begin
        exact s_EX
              dest=lop < rop;
        end;
     end,

   slt rdest rsrc1 rsrc2 macro
         begin
            slt__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,


#- SEQ__ : Set on Equal - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   seq__ rd rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_seq d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,       i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,    rop_type :integer_register,     i_type   :alu_type,
      l_dest_r :rd,                  l_dest2_r:none,                 l_lop_r  :rs,
      l_lop2_r :none,                l_rop_r  :rt,                   l_rop2_r :none
     )
     begin
        exact s_EX
              dest=lop == rop;
        end;
     end,

   seq rdest rsrc1 rsrc2 macro
         begin
            seq__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- SLTU__ : Set on Less than unsigned  - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sltu__ rd rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_sltu d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                 c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,     rop_type :integer_register,     i_type   :alu_type,
      l_dest_r :rd,                   l_dest2_r:none,                 l_lop_r  :rs,
      l_lop2_r :none,                 l_rop_r  :rt,                   l_rop2_r :none
     )
     begin
        exact s_EX
              dest=(+ lop) < (+ rop);            #MARK Must be unsigned.
        end;
     end,

   sltu rdest rsrc1 rsrc2 macro
         begin
            sltu__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- SRA__ : Shift word right arithmetic  - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sra__ rd rt immediate7 d1_d2_d3
     emit op0=_op0_ir op1=_sra rs=0 rt rd immediate7 d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,    i_cycles :single_cycle,        exu      :integer_unit,
      c_what   :none,             c_detail :none,                dest_type:integer_register,
      lop_type :none,             rop_type :integer_register,    i_type   :alu_type,
      l_dest_r :rd,               l_dest2_r:none,                l_lop_r  :none,
      l_lop2_r :none,             l_rop_r  :rt,                  l_rop2_r :none
     )
     begin
        exact s_EX
              dest=rop >> immediate7;
        end;
     end,

   sra rdest rsrc1 src2 macro
         begin
            sra__: rd=rdest rt=rsrc1 immediate7=src2 d1_d2_d3=nofnop;
         end,

#- SRAV__ : Shift word right arithmetic  - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   srav__  rd rt rs d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_srav d1_d2_d3 cf=1
     attributes
     (
      i_class :integer_class,      i_cycles :single_cycle,       exu      :integer_unit,
      c_what  :none,               c_detail :none,               dest_type:integer_register,
      lop_type:integer_register,   rop_type :integer_register,   i_type   :alu_type,
      l_dest_r:rd,                 l_dest2_r:none,               l_lop_r  :rs,
      l_lop2_r:none,               l_rop_r  :rt,                 l_rop2_r :none
     )
     begin
        exact s_EX
              dest=rop >> (lop.[4:5]);
        end;
     end,

   srav  rdest rsrc1 rsrc2 macro
         begin
            srav__ : rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

   sra  rdest rsrc1 rsrc2 macro
         begin
            srav__ : rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- SRL__ : Shift word right logical - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   srl__ rd rt immediate7 d1_d2_d3
     emit op0=_op0_ii op1=_srl rs=0 rt rd immediate7 d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,   i_cycles :single_cycle,           exu      :integer_unit,
      c_what   :none,            c_detail :none,                   dest_type:integer_register,
      lop_type :none,            rop_type :integer_register,       i_type   :alu_type,
      l_dest_r :rd,              l_dest2_r:none,                   l_lop_r  :none,
      l_lop2_r :none,            l_rop_r  :rt,                     l_rop2_r :none
     )
     begin
        exact s_EX
              dest=(+rop) >> (+immediate7);
        end;
     end,

   srl rdest rsrc1 src2 macro
         begin
            srl__: rd=rdest rt=rsrc1 immediate7=src2 d1_d2_d3=nofnop;
         end,

#- SRLV__: Shift word right logical variable  - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   srlv__ rd rt rs d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_srlv d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,       i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,    rop_type :integer_register,     i_type   :alu_type,
      l_dest_r :rd,                  l_dest2_r:none,                 l_lop_r  :rs,
      l_lop2_r :none,                l_rop_r  :rt,                   l_rop2_r :none
     )
     begin
        exact s_EX
              dest=(+rop) >> (+lop);
        end;
     end,

   srlv rdest rsrc1 rsrc2 macro
     begin
        srlv__ : rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
     end,

   srl  rdest rsrc1 rsrc2 macro
     begin
        srlv__ : rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
     end,

#- SUB__ : Subtract - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sub__ rd rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_sub d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,          i_cycles :single_cycle,           exu      :integer_unit,
      c_what   :none,                   c_detail :none,                   dest_type:integer_register,
      lop_type :integer_register,       rop_type :integer_register,       i_type   :alu_type,
      l_dest_r :rd,                     l_dest2_r:none,                   l_lop_r  :rs,
      l_lop2_r :none,                   l_rop_r  :rt,                     l_rop2_r :none
     )
     begin
        exact s_EX
              dest=lop - rop;
        end;
     end,

   sub rdest rsrc1 rsrc2 macro
         begin
            sub__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

#- ADDI : Add Immediate word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   addi__ rt rs s_immediate d1_d2_d3
     emit op0=_op0_i op1=_addi rs rt s_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,    i_cycles :single_cycle,     exu      :integer_unit,
      c_what   :none,             c_detail :none,             dest_type:integer_register,
      lop_type :integer_register, rop_type :none,             i_type   :alu_type,
      l_dest_r :rt,               l_dest2_r:none,             l_lop_r  :rs,
      l_lop2_r :none,             l_rop_r  :none,             l_rop2_r :none
     )
     begin
        exact s_ID
              simm=sign_extend_12(s_immediate);
        end;

        exact s_EX
              rop=simm;
              dest=lop + rop;
        end;
     end,

   addi rdest rsrc1 src2 macro
     begin
        if twelve_bit_signed_constant(src2) then
           inline "	addi__ $%d,$%d,%d,%d" rdest,rsrc1,src2,nofnop
        else
           begin
              printf("\n\n@-2. long: addiu constant : %08x \n\n",src2);
              inline "	lui20__ %d,%d" src2.[31:20],nofnop;
              if src2.[11:12] ^= 0 then
                 inline "	ori__  $1,$1,%d,%d" src2.[11:12],nofnop;
              inline "	add__ $%d,$%d,$1,%d" rdest, rsrc1, nofnop;
           end;
     end,

#- SUBU__ : Subtract word unsigned - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  subu__ rd rs rt d1_d2_d3
     emit op0=_op0_ii op1=_r_type rs rt rd immediate7=_subu d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,           exu      :integer_unit,
      c_what   :none,                 c_detail :none,                   dest_type:integer_register,
      lop_type :integer_register,     rop_type :integer_register,       i_type   :alu_type,
      l_dest_r :rd,                   l_dest2_r:none,                   l_lop_r  :rs,
      l_lop2_r :none,                 l_rop_r  :rt,                     l_rop2_r :none
     )
     begin
        exact s_EX
              dest=lop - rop;
        end;
     end,

   subu rdest rsrc1 rsrc2 macro
         begin
            subu__: rd=rdest rt=rsrc1 rs=rsrc2 d1_d2_d3=nofnop;
         end,

   subu rdest rsrc1 src2 macro
        begin
           if twelve_bit_signed_constant(src2) then
              inline "addi__ $%d,$%d,%d,%d" rdest,rsrc1,-src2,nofnop
           else
              begin
                 inline "li $1,%d" -src2;
                 inline "add__ $%d,$%d,$1,%d" rdest,rsrc1,nofnop;
              end;
        end,

   subu rdest src2 macro
        begin
           if twelve_bit_signed_constant(src2) then
              inline "addi__ $%d,$%d,%d,%d" rdest,rdest,-src2,nofnop
           else
              begin
                 inline "li $1,%d" -src2;
                 inline "add__ $%d,$%d,$1,%d" rdest,rdest,nofnop;
              end;
        end,

   negu rsrc1 rsrc2 macro
        begin
           inline "subu__ $%d,$0,$%d,%d" rsrc1,rsrc2,nofnop;
        end,


#- ADDIU__ : Add Immediate Unsigned Word - - - - - - - - - - - - - - - - - - - - - - - - MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   addiu__ rt rs s_immediate d1_d2_d3
     emit op0=_op0_i op1=_addiu rs rt s_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,     exu      :integer_unit,
      c_what   :none,                 c_detail :none,             dest_type:integer_register,
      lop_type :integer_register,     rop_type :none,             i_type   :alu_type,
      l_dest_r :rt,                   l_dest2_r:none,             l_lop_r  :rs,
      l_lop2_r :none,                 l_rop_r  :none,             l_rop2_r :none
     )
     begin
        exact s_ID
              simm=sign_extend_12(s_immediate);
        end;

        exact s_EX
              dest=lop + simm;
        end;
     end,

   addiu rdest rsrc1 src2 macro
     begin
        if twelve_bit_signed_constant(src2) then
           inline "	addiu__ $%d,$%d,%d,%d" rdest,rsrc1,src2,nofnop
        else
        if sixteen_bit_signed_constant(src2) then
           begin
              inline "	lls16__ $1,%d,%d" src2,nofnop;
              inline "	addu__ $%d,$%d,$1,%d" rdest, rsrc1, nofnop;
           end
        else
           begin
              printf("\n\n@-3. long: addiu constant : %08x \n\n",src2);
              inline "	lui20__ %d,%d" src2.[31:20],nofnop;
              inline "	ori__  $1,$1,%d,%d" src2.[11:12],nofnop;
              inline "	addu__ $%d,$%d,$1,%d" rdest, rsrc1, nofnop;
           end;
     end,

   addiu rdest src2 macro
     begin
        if twelve_bit_signed_constant(src2) then
           inline "	addiu__ $%d,$%d,%d,%d" rdest,rdest,src2,nofnop
        else
           begin
              printf("\n\n@-4. long: addiu constant : %08x \n\n",src2);
              inline "	lui20__ %d,%d" src2.[31:20],nofnop;
              inline "	ori__  $1,$1,%d,%d" src2.[11:12],nofnop;
              inline "	addu__ $%d,$%d,$1,%d" rdest, rdest, nofnop;
           end;
     end,

   addu rdest rsrc1 src2 macro
         begin
            inline "	addiu__ $%d,$%d,%d,%d" rdest,rsrc1,src2,nofnop;
         end,

   addu rdest src2 macro
         begin
            inline "	addiu__ $%d,$%d,%d,%d" rdest,rdest,src2,nofnop;
         end,


#- SLTI__ : Set on Less than Immediate - - - - - - - - - - - - - - - - - - - - - - - - - MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   slti__ rt rs s_immediate d1_d2_d3
     emit op0=_op0_i op1=_slti rs rt s_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                 c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,     rop_type :none,                 i_type   :alu_type,
      l_dest_r :rt,                   l_dest2_r:none,                 l_lop_r  :rs,
      l_lop2_r :none,                 l_rop_r  :none,                 l_rop2_r :none
     )
     begin
        exact s_ID
              simm=sign_extend_12(s_immediate);
        end;

        exact s_EX
              dest=lop < simm;
              # builtin printf("LOP=%d SIMM=%d Less=%d\n\n",lop,simm,dest);
        end;
     end,

   slti rdest rsrc1 src2 macro
     begin
        if pass1 == 0 then
           begin
              if twelve_bit_signed_constant(src2) then
                 inline "	slti__ $%d,$%d,%d,%d" rdest,rsrc1,src2,nofnop
              else
                 begin
                    printf("\n\n@-5. long: constant : %08x \n\n",src2);
                    printf("\n\nrdest %d rsrc1 %d\n\n",rdest,rsrc1);
                    inline "	lui20__ %d,%d" src2.[31:20],nofnop;
                    inline "	ori__  $1,$1,%d,%d" src2.[11:12],nofnop;
                    inline "	slt__ $%d,$%d,$1,%d" rdest,rsrc1,nofnop;
                 end;
           end;
     end,

   slt rdest rsrc1 src2 macro
     begin
        if pass1 == 0 then
           begin
              if twelve_bit_signed_constant(src2) then
                 inline "	slti__ $%d,$%d,%d,%d" rdest,rsrc1,src2,nofnop
              else
              if sixteen_bit_signed_constant(src2) then
                 begin
                    inline "    lls16__ $1,%d,%d" src2,nofnop;
                    inline "	slt__ $%d,$%d,$1,%d" rdest,rsrc1,nofnop;
                 end
              else
                 begin
                    tx = src2.[11:12];
                    ty = src2.[31:20];

                    if (ty ^= 0) & (tx ^= 0) then
                       begin
                          inline "	lui20__ %d,%d" ty,nofnop;
                          inline "	ori__  $1,$1,%d,%d" tx,nofnop;
                          printf("\n\n@-6. long: constant : %08x :",src2);
                          printf("rdest %d rsrc1 %d\n\n",rdest,rsrc1);
                       end
                    else
                    if (ty ^= 0) & (tx == 0) then
                       inline "	lui20__ %d,%d" ty,nofnop
                    else
                       inline "	ori__  $1,$0,%d,%d" tx,nofnop;
                    inline "	slt__ $%d,$%d,$1,%d" rdest,rsrc1,nofnop;
                 end;
           end;
     end,


#- SLTIU__ : Set on Less than Immediate Unsigned - - - - - - - - - - - - - - - - - - - - MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sltiu__ rt rs s_immediate d1_d2_d3
     emit op0=_op0_i op1=_sltiu rs rt s_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class   : integer_class,       i_cycles  : single_cycle,     exu       : integer_unit,
      c_what    : none,                c_detail  : none,             dest_type : integer_register,
      lop_type  : integer_register,    rop_type  : none,             i_type    : alu_type,
      l_dest_r  : rt,                  l_dest2_r : none,             l_lop_r   : rs,
      l_lop2_r  : none,                l_rop_r   : none,             l_rop2_r  : none
     )
     begin
        exact s_ID
              simm=sign_extend_12(s_immediate);
        end;

        exact s_EX
              dest=(+ lop) < (+ simm);               #MARK must be unsigned.
        end;
     end,

   sltiu rdest rsrc1 src2 macro
     begin
        if pass1 == 0 then
           begin
              if twelve_bit_signed_constant(src2) then
                 inline "	sltiu__ $%d,$%d,%d,%d" rdest,rsrc1,src2,nofnop
              else
                 begin
                    printf("\n\n@-7. long: constant : %08x \n\n",src2);
                    printf("\n\nrdest %d rsrc1 %d\n\n",rdest,rsrc1);
                    inline "	lui20__ %d,%d" src2.[31:20],nofnop;
                    inline "	ori__  $1,$1,%d,%d" src2.[11:12],nofnop;
                    inline "	slt__ $%d,$%d,$1,%d" rdest,rsrc1,nofnop;
                 end;
           end;
     end,

   sltu rdest rsrc1 src2 macro
     begin
        if pass1 == 0 then
           begin
              if twelve_bit_signed_constant(src2) then
                 inline "	sltiu__ $%d,$%d,%d,%d" rdest,rsrc1,src2,nofnop
              else
              if sixteen_bit_signed_constant(src2) then
                 begin
                    inline "    lls16__ $1,%d,%d" src2,nofnop;
                    inline "	sltu__ $%d,$%d,$1,%d" rdest,rsrc1,nofnop;
                 end
              else
                 begin
                    tx = src2.[11:12];
                    ty = src2.[31:20];

                    if (ty ^= 0) & (tx ^= 0) then
                       begin
                          inline "	lui20__ %d,%d" ty,nofnop;
                          inline "	ori__  $1,$1,%d,%d" tx,nofnop;
                          printf("\n\n@-8.a. long: constant : %08x :",src2);
                          printf("rdest %d rsrc1 %d\n\n",rdest,rsrc1);
                       end
                    else
                    if (ty ^= 0) & (tx == 0) then
                       inline "	lui20__ %d,%d" ty,nofnop
                    else
                       inline "	ori__  $1,$0,%d,%d" tx,nofnop;
                    inline "	sltu__ $%d,$%d,$1,%d" rdest,rsrc1,nofnop;
                 end;
           end;
     end,


#- ANDI__ : And Immediate - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   andi__ rt rs us_immediate d1_d2_d3
     emit op0=_op0_i op1=_andi rs rt us_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,     exu      :integer_unit,
      c_what   :none,                 c_detail :none,             dest_type:integer_register,
      lop_type :integer_register,     rop_type :none,             i_type   :alu_type,
      l_dest_r :rt,                   l_dest2_r:none,             l_lop_r  :rs,
      l_lop2_r :none,                 l_rop_r  :none,             l_rop2_r :none
     )
     begin
        exact s_ID
              zimm=zero_extend_12(us_immediate);
        end;

        exact s_EX
              dest=lop & zimm;
        end;
     end,

   andi rsrc1 rsrc2 src2 macro
     begin
        if pass1 == 0 then
           begin
              if twelve_bit_constant(src2) then
                 inline "	andi__ $%d,$%d,%d,%d" rsrc1,rsrc2,src2,nofnop
              else
              if sixteen_bit_constant(src2) & (rsrc1 == rsrc2) then
                 begin
                    #printf("@-16bc: constant (andi) ali16__ generated: %08x\n ",src2);
                    inline "	ali16__ $%d,%d,%d" rsrc1,src2,nofnop;
                 end
              else
              if sixteen_bit_constant(src2) then
                 begin
                    inline "	lli16__ $%d,%d,%d" rsrc1, src2,nofnop;
                    inline "	and__ $%d,$%d,$%d,%d" rsrc1,rsrc1,rsrc2,nofnop;
                 end
              else
                 begin
                    printf("\n\n@-9. long: constant : %08x \n\n",src2);
                    printf("\n\nrsrc1 %d rsrc2 %d\n\n",rsrc1,rsrc2);
                    inline "	lui20__ %d,%d" src2.[31:20],nofnop;
                    inline "	ori__  $1,$1,%d,%d" src2.[11:12],nofnop;
                    inline "	and__ $%d,$%d,$1,%d" rsrc1,rsrc2,nofnop;
                 end;
           end;
     end,

   and rsrc1 rsrc2 src2 macro
     begin
        if pass1 == 0 then
           begin
              if twelve_bit_constant(src2) then
                 inline "	andi__ $%d,$%d,%d,%d" rsrc1,rsrc2,src2,nofnop
              else
              if sixteen_bit_constant(src2) & (rsrc1 == rsrc2) then
                 begin
                    #printf("@-16bc: constant (and) ali16__ generated: %08x\n ",src2);
                    inline "	ali16__ $%d,%d,%d" rsrc1,src2,nofnop;
                 end
              else
                 begin
                    printf("\n\n@-10. long: constant : %08x \n",src2);
                    printf("\n\nrsrc1 %d rsrc2 %d\n\n",rsrc1,rsrc2);
                    inline "	lui20__ %d,%d" src2.[31:20],nofnop;
                    inline "	ori__ $1,$1,%d,%d" src2.[11:12],nofnop;
                    inline "	and__ $%d,$%d,$1,%d" rsrc1,rsrc2,nofnop;
                 end;
           end;
     end,


#- ADDIA__ : Add Immediate Word for Address Computation Uop  - - - - - - - - - - - - - - - LAZY -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   addia__ rt rs s_immediate d1_d2_d3
     emit op0=_op0_i op1=_addia rs rt s_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,       i_cycles :single_cycle,     exu      :integer_unit,
      c_what   :none,                c_detail :none,             dest_type:integer_register,
      lop_type :integer_register,    rop_type :none,             i_type   :alu_type,
      l_dest_r :rt,                  l_dest2_r:none,             l_lop_r  :rs,
      l_lop2_r :none,                l_rop_r  :none,             l_rop2_r :none
     )
     begin
        exact s_ID
              simm=sign_extend_12(s_immediate);
        end;

        exact s_EX
              rop=simm;
              dest=lop + rop;
        end;
     end,

#- XORI: Exclusive Or Immediate  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - LAZY -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   xori__ rt rs us_immediate d1_d2_d3
     emit op0=_op0_i op1=_xori rs rt us_immediate d1_d2_d3 cf=1
     attributes
     (
      i_class  :integer_class,          i_cycles :single_cycle,      exu      :integer_unit,
      c_what   :none,                   c_detail :none,              dest_type:integer_register,
      lop_type :integer_register,       rop_type :none,              i_type   :alu_type,
      l_dest_r :rt,                     l_dest2_r:none,              l_lop_r  :rs,
      l_lop2_r :none,                   l_rop_r  :none,              l_rop2_r :none
     )
     begin
        exact s_ID
              zimm=zero_extend_12(us_immediate);
        end;

        exact s_EX
              dest=lop ^ zimm;
        end;
     end,

   xor rsrc1 rsrc2 src2 macro
     begin
        if twelve_bit_constant(src2) then
           inline "xori__ $%d,$%d,%d,%d" rsrc1,rsrc2,src2,nofnop
        else
           begin
              if sixteen_bit_constant(src2) then
                 begin
                    inline "	lli16__ $1,%d,%d" src2,nofnop;
                 end
              else
                 begin
                    printf("\n\n@-13.a. Li for a 16 bit xor constant\n\n");
                    inline "li $1,%d" src2;
                 end;
              inline "xor__ $%d,$%d,$1,%d" rsrc1,rsrc2,nofnop;
           end;
     end,

   xori rsrc1 rsrc2 src2 macro
     begin
        if twelve_bit_constant(src2) then
           inline "xori__ $%d,$%d,%d,%d" rsrc1,rsrc2,src2,nofnop
        else
           begin
              if sixteen_bit_constant(src2) then
                 begin
                    inline "	lli16__ $1,%d,%d" src2,nofnop;
                 end
              else
                 begin
                    printf("\n\n@-13.b. Li for a 16 bit xor constant\n\n");
                    inline "li $1,%d" src2;
                 end;
              inline "xor__ $%d,$%d,$1,%d" rsrc1,rsrc2,nofnop;
           end;
     end,

#- CTC1__ : Move Control Word to Floating Point - - - - - - - - - - - - - - - - - - - - - MIPS-I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   ctc1__ rt fs d1_d2_d3
         emit op0=_op0_cop op1=_ct cond=0 rt fs copf3=0 d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : none,
              rop_type  : integer_register,
              i_type    : alu_type,
              l_dest_r  : fs + 34,
              l_dest2_r : none,
              l_lop_r   : none,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_EX
                  dest=rop;
            end;
         end,

   ctc1 rdest rsrc1 macro
         begin
            ctc1__: rt=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,


   cfc1__ rt fs d1_d2_d3
         emit op0=_op0_cop op1=_cf cond=0 rt fs copf3=0 d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_EX
                  dest=lop;
            end;
         end,

   cfc1 rdest rsrc1 macro
         begin
            cfc1__: rt=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,


#- J__ : Jump  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I- #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   j__ j_offset d1_d2_d3
         emit op0=_op0_j j_offset d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_z,
              c_detail  : unconditional_direct,
              dest_type : none,
              lop_type  : none,
              rop_type  : none,
              i_type    : branch_type_0,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : none,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  branch_target=my_pc.[31:5] || j_offset || 0 |< 2;
            end;
         end,

   j address macro
         begin
            j__ : j_offset=<address.absolute.jump_address> d1_d2_d3=nofnop;
         end,

   b address macro
         begin
            j__ : j_offset=<address.absolute.jump_address> d1_d2_d3=nofnop;
         end,


#- JAL__ : Jump and link  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   jal__ j_offset d1_d2_d3
         emit op0=_op0_jal j_offset d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_z,
              c_detail  : unconditional_direct_link,
              dest_type : integer_register,
              lop_type  : none,
              rop_type  : none,
              i_type    : branch_type_1,
              l_dest_r  : 31,
              l_dest2_r : none,
              l_lop_r   : none,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  branch_target=my_pc.[31:5] || j_offset || 0 |< 2;
            end;

            exact s_EX
                  dest=my_pc + 4;
                  # if monitor then
                  history branch_target : dest;
            end;
         end,

   jal address macro
         begin
            jal__ : j_offset=<address.absolute.jump_address> d1_d2_d3=nofnop;
         end,

#- LB__ : Load byte - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lb__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lb rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : load_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
                  byte=lmar.[1:2];
            end;

            exact s_MEM
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;

                  if mem_stat | ls_bypass then
                     begin
                        if byte == 0 then
                           dest = dest.[07:08]
                        else
                        if byte == 1 then
                           dest = dest.[15:08]
                        else
                        if byte == 2 then
                           dest = dest.[23:08]
                        else
                           dest = dest.[31:08];
                        dest=sign_extend_24(dest);
                     end;
            end;
         end,

   lb rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lb__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lb__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lb rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lb__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,


#- LBU__ : Load byte unsigned  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lbu__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lbu rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : load_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
                  byte=lmar.[1:2];
            end;

            exact s_MEM
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;

                  if mem_stat | ls_bypass then
                     begin
                        if byte == 0 then
                           dest = dest.[07:08]
                        else
                        if byte == 1 then
                           dest = dest.[15:08]
                        else
                        if byte == 2 then
                           dest = dest.[23:08]
                        else
                           dest = dest.[31:08];
                        dest=(0 |< 24) || dest.[7:8];
                     end;
            end;
         end,


   lbu rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lbu__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lbu__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lbu rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lbu__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,


#- LH__  : Load half word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lh__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lh  rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : load_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
                  byte=lmar.[1:2];
            end;

            exact s_MEM
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;

                  if mem_stat | ls_bypass then
                     begin
                        if byte == 0 then
                           dest=sign_extend_16(dest.[15:16])
                        else
                        if byte == 2 then
                           dest=sign_extend_16(dest.[31:16]);
                     end;
            end;

         end,

   lh rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lh__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lh__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lh rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lh__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,


#- LHU : Load half word unsigned  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lhu__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lhu  rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : load_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
                  byte=lmar.[1:2];
            end;

            exact s_MEM
                  if ls_bypass == 0 then
                     begin
                        dest2=dcache [lmar];
                        mem_stat=access_complete;
                     end;

                  if mem_stat | ls_bypass then
                     begin
                        if byte == 0 then
                           dest=zero_extend_16(dest2.[15:16])
                        else
                        if byte == 2 then
                           dest=zero_extend_16(dest2.[31:16]);
                     end;
            end;

         end,

   lhu rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lhu__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lhu__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lhu rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lhu__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,

#- LW  : Load word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lw__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lw  rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : load_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
            end;

            exact s_MEM
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;
            end;

         end,

   lw rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lw__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lw__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lw rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lw__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,

   ll rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lw__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,

   ll rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lw__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lw__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lw rdest rsrc1 src2 macro
      begin
         inline "	lw	$%d,%d($%d)"	rdest,src2,rsrc1;
      end,


#- LWL__ : Load word left - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lwl__  rt rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lwl  rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : load_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
                  byte=lmar.[1:2];
                  lmar=lmar & 0xfffffffc;
            end;

            exact s_MEM
                  #if (my_pc == 0x10089588) & (cycles > 58000) then pause;
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;

                  if mem_stat | ls_bypass then
                     begin
                        if byte == 0 then
                           dest=dest.[07:08] || rop.[23:24]
                        else
                        if byte == 1 then
                           dest=dest.[15:16] || rop.[15:16]
                        else
                        if byte == 2 then
                           dest=dest.[23:24] || rop.[07:08];
                     end;
            end;
         end,

   lwl rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lwl__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lwl__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lwl rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lwl__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,


#- LWR__ : Load word right- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lwr__  rt rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lwr  rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : load_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12 (s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
                  byte=lmar.[1:2];
            end;

            exact s_MEM
                  #if (my_pc == 0x10089584) & (cycles > 58000) then pause;
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;

                  if mem_stat | ls_bypass then
                     begin
                        if byte == 1 then
                           dest = rop.[31:08] || dest.[31:24]
                        else
                        if byte == 2 then
                           dest = rop.[31:16] || dest.[31:16]
                        else
                        if byte == 3 then
                           dest = rop.[31:24] || dest.[31:08];
                     end;
            end;
         end,

   lwr rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            lwr__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lwr__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   lwr rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         lwr__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,


#- SB__  : Store byte  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sb__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ms op1=_sb rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : store_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : store_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  smar=lop + simm;

                  byte=smar.[1:2];
                  if byte == 1 then
                     smdr = rop.[23:24] || (0 |< 8)
                  else
                  if byte == 2 then
                     smdr = rop.[15:16] || (0 |< 16)
                  else
                  if byte == 3 then
                     smdr = rop.[07:08] || (0 |< 24)
                  else
                     smdr = rop;
                  access_type=_BYTE;
            end;
         end,

   sb rdest address_bo macro
      begin
         tx = <address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            begin
               sb__ : rt=rdest rs=<address_bo.base> s_immediate=tx d1_d2_d3=nofnop;
            end
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               sb__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
            end;
      end,

   sb rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         sb__  : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,

#- SH  : Store halfword  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sh__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ms op1=_sh rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : store_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : store_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  smar=lop + simm;

                  byte=smar.[1:2];
                  if byte == 2 then
                     smdr = rop.[15:16] || (0 |< 16)
                  else
                     smdr = rop;
                  access_type=_HALFWORD;
            end;
         end,

   sh rdest address_bo macro
      begin
         tx = <address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            begin
               sh__ : rt=rdest rs=<address_bo.base> s_immediate=tx d1_d2_d3=nofnop;
            end
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               sh__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
            end;
      end,

   sh rdest address macro
        begin
           lui20__: immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
           sh__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
        end,

#- SW : Store word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   sw__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ms op1=_sw rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : store_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : store_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  smar=lop + simm;
                  smdr=rop;
                  access_type=_WORD;
            end;
         end,

   sw rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            sw__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               sw__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   sw rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         sw__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,


   sw rdest rsrc1 src2 macro
      begin
         inline "	sw	$%d,%d($%d)"	rdest,src2,rsrc1;
      end,

   sc rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         sw__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,

   sc rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            sw__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               sw__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,


#- SWL__: Store word left - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   swl__ rt rs s_immediate d1_d2_d3
         emit op0=_op0_ms op1=_swl rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : store_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : store_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  smar=lop + simm;

                  byte=( smar.[1:2] ) ^ 0;

                  if byte == 0 then
                     smdr =0 |< 24 || rop.[31:08]
                  else
                  if byte == 1 then
                     smdr =0 |< 16 || rop.[31:16]
                  else
                  if byte == 2 then
                     smdr =0 |< 8 || rop.[31:24]
                  else
                     smdr = rop;
                  access_type=byte;
            end;
         end,

   swl rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            swl__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               swl__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   swl rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         swl__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,



#- SWR__: Store word right- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   swr__  rt rs s_immediate d1_d2_d3
         emit op0=_op0_ms op1=_swr rs rt s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : store_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : store_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  smar=lop + simm;

                  byte=smar.[1:2];

                  if byte == 1 then
                     smdr =rop.[23:24] || (0 |< 8)
                  else
                  if byte == 2 then
                     smdr =rop.[15:16] || (0 |< 16)
                  else
                  if byte == 3 then
                     smdr =rop.[07:08] || (0 |< 24)
                  else
                     smdr = rop;
                  access_type=_WORD-byte;
            end;
         end,

   swr rdest address_bo macro
      begin
         tx=<address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            swr__ : rt=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               swr__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
      end,

   swr rdest address macro
      begin
         lui20__ : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
         swr__ : rt=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
      end,

#- Additional Macros - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   beq rsrc1 rsrc2 address macro
         begin
            if rsrc2 == 0 then
               begin
                  inline "biff $%d,%s" rsrc1,address;
               end
            else
               begin
                  #printf("@seq-pair:%d %d\n",rsrc1,rsrc2);
                  inline "seq__ $1,$%d,$%d,%d" rsrc1,rsrc2,nofnop;
                  inline "bift $1,%s" address;
               end;
         end,

   bne rsrc1 rsrc2 address macro
         begin
            if rsrc2 == 0 then
               begin
                  inline "bift $%d,%s" rsrc1,address;
               end
            else
               begin
                  #printf("@seq-pair:%d %d\n",rsrc1,rsrc2);
                  inline "seq $1,$%d,$%d" rsrc1,rsrc2;
                  inline "biff $1,%s" address;
               end;
         end,

   nop macro
         begin
            sll__  : rd=0 rt=0 immediate7=0 d1_d2_d3=nofnop;
         end,

   move rdest rsrc1      macro
         begin
            addu__ : rd=rdest rs=rsrc1 rt=0 d1_d2_d3=nofnop;
         end,


   rdhwr rdest rsrc1      macro
         begin
            addu__ : rd=rdest rs=rsrc1 rt=0 d1_d2_d3=nofnop;
         end,

#- LA : Load address macros- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lalui rdest address macro
         begin
            lui20__: immediate20=<address.absolute.upper20> d1_d2_d3=nofnop;
         end,

   laori   rdest rsrc1  address macro
         begin
            ori__  : rt=rdest rs=rsrc1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
         end,

   la rdest address macro
         begin
            lui20__: immediate20=<address.absolute.upper20> d1_d2_d3=nofnop;
            ori__  : rt=rdest rs=1 s_immediate=<address.absolute.lower12> d1_d2_d3=nofnop;
         end,

   la rdest address_bo macro
      begin
         tx = <address_bo.offset>;
         if twelve_bit_signed_constant(tx) then
            begin
               addi__ : rt=rdest rs=<address_bo.base> s_immediate=tx d1_d2_d3=nofnop;
            end
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               if rdest ^= 1 then
               addi__ : rt=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
            end;
      end,

   la rdest src2 macro
      begin
         inline "li $%d,%d" rdest,src2;
      end,

#- LI : Load immediate macro - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   li rdest src2 macro
      begin
         if sixteen_bit_signed_constant(src2) then
            inline "    lls16__ $%d,%d,%d" rdest,src2,nofnop
         else
            begin
               ty = src2.[31:16];
               tx = src2.[15:16];
               if ty ^= 0 then
                  begin
                     inline "     lui16__ $%d,%d,%d" rdest,ty,nofnop;
                     if tx ^= 0 then
                        inline "     oli16__ $%d,%d,%d" rdest,ty,nofnop;
                  end
               else
                  inline "	lli16__ $%d,%d,%d" rdest,src2,nofnop;
            end;
      end,

#- Floating Point Instructions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
#                                                                                                #
#                                                                                                #
#  Most MIPS floating point instructions are included with a different binary format.            #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #


#- LWC1__ : Load word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   lwc1__ ft rs s_immediate d1_d2_d3
         emit op0=_op0_ml op1=_lwc1 rs ft s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : load_type,
              l_dest_r  : ft + 34,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  lmar=lop + simm;
            end;

            exact s_MEM
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;
            end;

         end,

   lwc1 rdest address_bo macro
         begin
            tx=<address_bo.offset>;
            if twelve_bit_signed_constant(tx) then
               lwc1__ : ft=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
         else
            begin
               add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
               lwc1__ : ft=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
           end;
         end,

   lwc1 rdest address macro
        begin
           lui20__  : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
           lwc1__ : ft=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
        end,

   "l.s" rdest address macro
        begin
           lwc1__: ft=rdest rs=<address.base> s_immediate=<address.offset> d1_d2_d3=nofnop;
        end,


   "l.d" rdest address macro
        begin
           lwc1__: ft=rdest   rs=<address.base> s_immediate=<address.offset> d1_d2_d3=nofnop;
           lwc1__: ft=rdest+1 rs=<address.base> s_immediate=<address.offset.add4> d1_d2_d3=nofnop;
        end,

#- SWC1__ : Store word  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   swc1__ ft rs s_immediate d1_d2_d3
         emit op0=_op0_ms op1=_swc1 rs ft s_immediate d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : store_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : float_register,
              i_type    : store_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : rs,
              l_lop2_r  : none,
              l_rop_r   : ft + 34,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  simm=sign_extend_12(s_immediate);
            end;

            exact s_EX
                  smar=lop + simm;
                  smdr=rop;
                  access_type=_WORD;
            end;
         end,

   swc1 rdest address_bo macro
         begin
            tx=<address_bo.offset>;
            if twelve_bit_signed_constant(tx) then
               swc1__ : ft=rdest rs=<address_bo.base> s_immediate=<address_bo.offset> d1_d2_d3=nofnop
            else
               begin
                  add16__: rs=<address_bo.base> immediate16=<address_bo.offset> d1_d2_d3=nofnop;
                  swc1__ : ft=rdest rs=1 s_immediate=0 d1_d2_d3=nofnop;
              end;
         end,

   swc1 rdest address macro
        begin
           lui20__  : immediate20=<address.absolute.upperm> d1_d2_d3=nofnop;
           swc1__ : ft=rdest rs=1 s_immediate=<address.absolute.lowerc> d1_d2_d3=nofnop;
        end,

   "s.d" rdest address macro
        begin
           swc1__: ft=rdest   rs=<address.base> s_immediate=<address.offset> d1_d2_d3=nofnop;
           swc1__: ft=rdest+1 rs=<address.base> s_immediate=<address.offset.add4> d1_d2_d3=nofnop;
        end,

   "s.s" rdest address macro
        begin
           swc1__: ft=rdest rs=<address.base> s_immediate=<address.offset> d1_d2_d3=nofnop;
        end,


#- CVT.D.FMT__ Floating point convert to double floating point format - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#      These are a set of instructions where the FMT indicates the data type.                    #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   "cvt.d.w__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_single_fixed cond=_cvt_d_fmt ft=0 fs fd ufc=fc_cvt d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  # builtin printf("FIXED value is %d\n",lop);

                  builtin convert_from_fixed_to_double(lop,dtemp);
                  dest=dtemp[0];
                  dest2=dtemp[1];
            end;
         end,

   "cvt.d.w" rdest rsrc1 macro
         begin
           "cvt.d.w__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,

   "cvt.d.s__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_cvt_d_fmt ft=0 fs fd ufc=fc_cvt d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  builtin convert_from_float_to_double(lop,dtemp);
                  dest =dtemp[0];
                  dest2=dtemp[1];
            end;
         end,

   "cvt.d.s" rdest rsrc1 macro
         begin
           "cvt.d.s__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,


#- CVT.S.FMT__ Floating point convert to single floating point format - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#      These are a set of instructions where the FMT indicates the data type.                    #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   "cvt.s.w__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_single_fixed cond=_cvt_s_fmt ft=0 fs fd ufc=fc_cvt d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  builtin convert_from_fixed_to_float(lop,dtemp);
                  dest=dtemp[0];
            end;
         end,

   "cvt.s.w" rdest rsrc1 macro
         begin
           "cvt.s.w__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,


   "cvt.s.d__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_cvt_s_fmt ft=0 fs fd ufc=fc_cvt d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : double_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest=@dtof({lop,lop2});
            end;
         end,

   "cvt.s.d" rdest rsrc1 macro
         begin
           "cvt.s.d__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,

#- LI.s : Load immediate single precision value/ Load immediate double precision value  - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#      These are two macros used for FP constant loads.                                          #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  "li.s"   rdest fsrc2 macro
           if pass1 then
              begin
              end
           else
              begin
                 if builtin strncmp(token_name(rdest),"$f",2) == 0 then
                    begin
                       inline "	li   $1,0x%08x" builtin float_to_hex(fsrc2);
                       inline "	mtc1 $1,$f%d"  rdest;
                    end
                 else
                    inline "	li   $%d,0x%08x" rdest,builtin float_to_hex(fsrc2);
              end,

  "li.d"   rdest fsrc2 macro
           if pass1 then
              begin
              end
           else
              begin
                 if builtin strncmp(token_name(rdest),"$f",2) == 0 then
                    begin
                       inline "	li   $1,0x%08x" builtin double_to_hex_1(fsrc2);
                       inline "	mtc1 $1,$f%d"  rdest;
                       inline "	li   $1,0x%08x" builtin double_to_hex_2(fsrc2);
                       inline "	mtc1 $1,$f%d"  rdest+1;
                    end
                 else
                    begin
                       inline "	li   $%d,0x%08x" rdest,builtin double_to_hex_1(fsrc2);
                       inline "	li   $%d,0x%08x" rdest+1,builtin double_to_hex_2(fsrc2);
                    end;
              end,

#- DIV.FMT: Floating point divide - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   "div.d__"  fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_fdiv ft fs fd ufc=fc_arithmetic d1_d2_d3  cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_mul_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : double_register,
              rop_type  : double_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : ft + 34,
              l_rop2_r  : ft + 35
             )
         begin
            exact s_ID
                  latency 7; # was 14;
            end;

            exact f_mul3
                  {dest,dest2}={lop,lop2} @ddiv {rop,rop2};
            end;
         end,


   "div.s__" fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_fdiv ft fs fd ufc=fc_arithmetic d1_d2_d3  cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_mul_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : float_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : ft + 34,
              l_rop2_r  : none
             )
         begin
            exact s_ID
                  latency 7;
            end;

            exact f_mul3
                  dest=lop @fdiv rop;
            end;
         end,

   "div.d" rdest rsrc1 rsrc2 macro
         begin
           "div.d__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,

   "div.s" rdest rsrc1 rsrc2 macro
         begin
           "div.s__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,

#- MUL.FMT: Floating point multiply - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   "mul.s__" fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_fmul ft fs fd ufc=fc_arithmetic d1_d2_d3  cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_mul_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : float_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : ft + 34,
              l_rop2_r  : none
             )
         begin
            exact f_mul3
                  dest=lop @fmul rop;
            end;
         end,


   "mul.d__" fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_fmul ft fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_mul_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : double_register,
              rop_type  : double_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : ft + 34,
              l_rop2_r  : ft + 35
             )
         begin
            exact f_mul3
                  {dest,dest2}={lop,lop2} @dmul {rop,rop2};
            end;
         end,

   "mul.s" rdest rsrc1 rsrc2 macro
         begin
           "mul.s__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,

   "mul.d" rdest rsrc1 rsrc2 macro
         begin
           "mul.d__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,


#- ADD.FMT: Floating point add  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   "add.s__" fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_fadd ft fs fd ufc=fc_arithmetic d1_d2_d3  cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : float_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : ft + 34,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest=lop @fadd rop;
            end;
         end,


   "add.d__" fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_fadd ft fs fd ufc=fc_arithmetic d1_d2_d3  cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : double_register,
              rop_type  : double_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : ft + 34,
              l_rop2_r  : ft + 35
             )
         begin
            exact f_add3
                  {dest,dest2} = {lop,lop2} @dadd {rop,rop2};
            end;
         end,

   "add.s" rdest rsrc1 rsrc2 macro
         begin
           "add.s__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,

   "add.d" rdest rsrc1 rsrc2 macro
         begin
           "add.d__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,


#- NEG.FMT: Floating Point Negate - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   "neg.s__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_fneg ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest = @negf(lop);
            end;
         end,

   "neg.d__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_fneg ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : double_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  {dest,dest2} = @negd({lop,lop2});
            end;
         end,

   "neg.s" rdest rsrc1 macro
         begin
           "neg.s__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,

   "neg.d" rdest rsrc1 macro
         begin
           "neg.d__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,


#- SUB.FMT: Floating Point Subtract - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   "sub.s__" fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_fsub ft fs fd ufc=fc_arithmetic d1_d2_d3  cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : float_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : ft + 34,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest=lop @fsub rop;
            end;
         end,


   "sub.d__" fd fs ft d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_fsub ft fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : double_register,
              rop_type  : double_register,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : ft + 34,
              l_rop2_r  : ft + 35
             )
         begin
            exact f_add3
                  {dest,dest2} = {lop,lop2} @dsub {rop,rop2};
            end;
         end,

   "sub.s" rdest rsrc1 rsrc2 macro
         begin
           "sub.s__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,

   "sub.d" rdest rsrc1 rsrc2 macro
         begin
           "sub.d__" : fd=rdest fs=rsrc1 ft=rsrc2 d1_d2_d3=nofnop;
         end,

#- MFC1 : Move from coprocessor 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   mfc1__ rt fs d1_d2_d3
         emit op0=_op0_cop op1=_mf cond=0 rt fs copf3=0 d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : rt,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact s_EX
                  dest=lop;
            end;
         end,

   mfc1 rdest rsrc1 macro
         begin
            mfc1__: rt=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,

   "mfc1.d"  rsrc1 rsrc2 macro
         begin
            inline "mfc1 $%d,$f%d" rsrc1,rsrc2;
            inline "mfc1 $%d,$f%d" rsrc1+1,rsrc2+1;
         end,

#- MTC1 : Move to coprocessor 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

   mtc1__ rt fs d1_d2_d3
         emit op0=_op0_cop op1=_mt cond=0 rt fs copf3=0 d1_d2_d3 cf=1
         attributes
             (
              i_class   : integer_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : none,
              rop_type  : integer_register,
              i_type    : alu_type,
              l_dest_r  : fs + 34,
              l_dest2_r : none,
              l_lop_r   : none,
              l_lop2_r  : none,
              l_rop_r   : rt,
              l_rop2_r  : none
             )
         begin
            exact s_EX
                  dest=rop;
            end;
         end,

   mtc1 rdest rsrc1 macro
         begin
            mtc1__: rt=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,

   "mtc1.d"  rsrc1 rsrc2 macro
         begin
            inline "mtc1 $%d,$f%d" rsrc1,rsrc2;
            inline "mtc1 $%d,$f%d" rsrc1+1,rsrc2+1;
         end,


#- BC1F: Branch on FP false - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  bc1f__ simmediate16 d1_d2_d3
         emit op0=_op0_cop op1=_bc cond=0 simmediate16 tf=0 d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_equal,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : cpc_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : cpc_register_number + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             ),

  bc1f   address macro
         begin
            bc1f__ : simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,


#- BC1F: Branch on FP true  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  bc1t__ simmediate16 d1_d2_d3
         emit op0=_op0_cop op1=_bc cond=0 simmediate16 tf=1 d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : single_cycle,
              exu       : integer_unit,
              c_what    : condition_equal,
              c_detail  : conditional_direct,
              dest_type : none,
              lop_type  : cpc_register,
              rop_type  : none,
              i_type    : branch_type_2,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : cpc_register_number + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             ),

  bc1t   address macro
         begin
            bc1t__ : simmediate16=<address.delta.branch_address16> d1_d2_d3=nofnop;
         end,

#- C.Cond.Fmt - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  "c.cond.s__" fs ft cond d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond ft fs uccf=0 ufzf=0 ufc=fc_c_fmt d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : float_register,
              i_type    : alu_type,
              l_dest_r  : cpc_register_number + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : ft + 34,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  if @fnan(lop) | @fnan(rop) then
                     begin
                        less=0;
                        equal=0;
                        unordered=1;
                     end
                  else
                     begin
                        less=lop  @fless  rop;
                        equal=lop @fequal rop;
                        unordered=0;
                     end;
                  dest=(((cond.[2:1]) & less)  |
                       ((cond.[1:1]) & equal) |
                       ((cond.[0:1]) & unordered));
            end;
         end,

  "c.cond.d__" fs ft cond d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond ft fs uccf=0 ufzf=0 ufc=fc_c_fmt d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : double_register,
              rop_type  : double_register,
              i_type    : alu_type,
              l_dest_r  : cpc_register_number + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : ft + 34,
              l_rop2_r  : ft + 35
             )
         begin
            exact f_add3
                  if @dnan({lop,lop2}) |
                     @dnan({rop,rop2}) then
                     begin
                        less=0;
                        equal=0;
                        unordered=1;
                     end
                  else
                     begin
                        less={lop,lop2}  @dless  {rop,rop2};
                        equal={lop,lop2} @dequal {rop,rop2};
                        unordered=0;
                     end;
                  dest=(((cond.[2:1]) & less)  |
                       ((cond.[1:1]) & equal) |
                       ((cond.[0:1]) & unordered));
            end;
         end,

  "c.ult.s" rsrc1 rsrc2 macro
           begin
               "c.cond.s__" : fs=rsrc1 ft=rsrc2 cond=_fcond_ult d1_d2_d3=nofnop; #   0 1 0 1,   Unordered or less than /
           end,

  "c.ult.d" rsrc1 rsrc2 macro
           begin
               "c.cond.d__" : fs=rsrc1 ft=rsrc2 cond=_fcond_ult d1_d2_d3=nofnop; #   0 1 0 1,   Unordered or less than /
           end,

  "c.un.s" rsrc1 rsrc2 macro
           begin
               "c.cond.s__" : fs=rsrc1 ft=rsrc2 cond=_fcond_un d1_d2_d3=nofnop; #    0 0 0 1,  # Unordered/ordered (OR)
           end,

  "c.un.d" rsrc1 rsrc2 macro
           begin
               "c.cond.d__" : fs=rsrc1 ft=rsrc2 cond=_fcond_un d1_d2_d3=nofnop; #    0 0 0 1,  # Unordered/ordered (OR)
           end,

  "c.eq.d" rsrc1 rsrc2 macro
           begin
            "c.cond.d__" : fs=rsrc1 ft=rsrc2 cond=_fcond_eq d1_d2_d3=nofnop;
           end,

  "c.ueq.d" rsrc1 rsrc2 macro
           begin
            "c.cond.d__" : fs=rsrc1 ft=rsrc2 cond=_fcond_ueq d1_d2_d3=nofnop;
           end,

  "c.lt.d" rsrc1 rsrc2 macro
           begin
            "c.cond.d__" : fs=rsrc1 ft=rsrc2 cond=_fcond_lt d1_d2_d3=nofnop;
           end,

  "c.le.d" rsrc1 rsrc2 macro   # untested.
           begin
            "c.cond.d__" : fs=rsrc1 ft=rsrc2 cond=_fcond_le d1_d2_d3=nofnop;
           end,

  "c.eq.s" rsrc1 rsrc2 macro
           begin
            "c.cond.s__" : fs=rsrc1 ft=rsrc2 cond=_fcond_eq d1_d2_d3=nofnop;
           end,

  "c.le.s" rsrc1 rsrc2 macro   # untested.
           begin
            "c.cond.s__" : fs=rsrc1 ft=rsrc2 cond=_fcond_le d1_d2_d3=nofnop;
           end,

  "c.lt.s" rsrc1 rsrc2 macro
           begin
            "c.cond.s__" : fs=rsrc1 ft=rsrc2 cond=_fcond_lt d1_d2_d3=nofnop;
           end,

#- ABS.fmt : Absolute value - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  "abs.s__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_abs_fmt ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest=@fabs (lop);
            end;
         end,


  "abs.d__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_abs_fmt ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : double_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  {dest,dest2} = @dabs({lop,lop2});
            end;
         end,

   "abs.s" rdest rsrc1 macro
         begin
           "abs.s__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,

   "abs.d" rdest rsrc1 macro
         begin
           "abs.d__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,


#- MOV.fmt : Move values between float registers  - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  "mov.s__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_mov_fmt ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest=lop;
            end;
         end,


  "mov.d__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_mov_fmt ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : double_register,
              lop_type  : double_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : fd + 35,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest =lop;
                  dest2=lop2;
            end;
         end,

   "mov.s" rdest rsrc1 macro
         begin
           "mov.s__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,

   "mov.d" rdest rsrc1 macro
         begin
           "mov.d__" : fd=rdest fs=rsrc1 d1_d2_d3=nofnop;
         end,


#- Trunc.w.fmt : Floating point truncate to word fixed point  - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#                                                                                                #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

  "trunc.w.s__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_single_float cond=_trunc_w ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : float_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : none,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest=@ftrunc(lop);
            end;
         end,


  "trunc.w.d__" fd fs d1_d2_d3
         emit op0=_op0_cop op1=_double_float cond=_trunc_w ft=0 fs fd ufc=fc_arithmetic d1_d2_d3 cf=1
         attributes
             (
              i_class   : float_class,
              i_cycles  : multiple_cycles,
              exu       : f_add_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : float_register,
              lop_type  : double_register,
              rop_type  : none,
              i_type    : alu_type,
              l_dest_r  : fd + 34,
              l_dest2_r : none,
              l_lop_r   : fs + 34,
              l_lop2_r  : fs + 35,
              l_rop_r   : none,
              l_rop2_r  : none
             )
         begin
            exact f_add3
                  dest=@ftruncd({lop,lop2});
            end;
         end,

  "trunc.w.s" rsrc1 rsrc2 macro
           begin
             "trunc.w.s__" : fd=rsrc1 fs=rsrc2 d1_d2_d3=nofnop;
           end,

  "trunc.w.d" rsrc1 rsrc2 macro
           begin
             "trunc.w.d__" : fd=rsrc1 fs=rsrc2 d1_d2_d3=nofnop;
           end,

  "trunc.w.s" rsrc1 rsrc2 rsrc3 macro  # Untested - suspicious
           begin
             "trunc.w.s__" : fd=rsrc1 fs=rsrc2 d1_d2_d3=nofnop;
           end,

  "trunc.w.d" rsrc1 rsrc2 rsrc3 macro  # Untested - suspicious
           begin
             "trunc.w.d__" : fd=rsrc1 fs=rsrc2 d1_d2_d3=nofnop;
           end,



#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#  NEW Untested macros/instructions.                                          #
#                                                                             #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#

".cpload" rdest macro
          begin
             #inline "	li        $gp,%08x        " H.sbss_segment_start;
             inline "   addu__      $gp,$gp,$%d,%d  " rdest,nofnop;
          end,

".cpadd" rdest macro
          begin
             inline "   addu__      $%d,$28,$0,%d   " rdest,nofnop;
          end,

".cprestore" src2 macro
          begin
             inline "	sw	$gp,%d($sp)" src2;
             #cp_offset = src2;
             #cp_restoring = true;
          end,

#
#- These instructions are meaningful in a processor with syncronization issues.
#
#- Sync means all prior stores/loads have finished. We ignore it.
#
"sync" macro
       begin
       end

;


controlflow
    bift__,
    biff__,
    bgtz__,
    blez__,
    bltz__,
    bltzal__,
    bgez__,
    bgezal__,

    #bc1f__,
    #bc1t__,
    j__,
    jal__,
    jalr__,
    jr__;

 instruction category integer_arithmetic
    lui20__,
    lui16__,
    oli16__,
    ali16__,
    add16__,
    lli16__,
    lls16__,
    ctc1__,
    cfc1__,
    div__,
    divu__,
    add__,
    addi__,
    addiu__,
    addia__,
    addu__,
    and__,
    andi__,
    mfhi__,
    mflo__,
    mtlo__,
    mult__,
    multu__,
    nor__,
    or__,
    ori__,
    sll__,
    sllv__,
    slt__,
    seq__,
    slti__,
    sltiu__,
    sltu__,
    sra__,
    srav__,
    srl__,
    srlv__,
    sub__,
    subu__,
    syscall__,
    xor__,
    xori__;


instruction category conditional_branch
   bift__,
   biff__,
   bgtz__,
   blez__,
   bltz__,
   bltzal__,
   bgez__,
   bgezal__;

instruction category other
   break__;

instruction category unconditional_branch
   j__,
   jal__,
   jalr__,
   jr__;

instruction category load
   lb__,
   lbu__,
   lh__,
   lhu__,
   ll,
   lw__,
   lwl__,
   lwr__,
   lwc1__;


instruction category store
   sb__,
   sc,
   sh__,
   sw__,
   swl__,
   swr__,
   swc1__;

instruction category float_arithmetic
   "add.d__",
   "add.s__",
   "cvt.d.s__",
   "cvt.d.w__",
   "cvt.s.d__",
   "cvt.s.w__",
   "div.d__",
   "div.s__",
   "mul.d__",
   "mul.s__",
   "neg.d__",
   "neg.s__",
   "sub.d__",
   "sub.s__",
   mfc1__,
   mtc1__,
   "c.cond.d__",
   "c.cond.s__",
   "abs.s__",
   "abs.d__",
   "mov.s__",
   "mov.d__",
   "trunc.w.s__",
   "trunc.w.d__";

instruction category float_conditional
    bc1f__,
    bc1t__;

#   bne rsrc1 src2 address macro
#         begin
#            ty = src2.[31:20];
#            tx = src2.[11:12];
#            lui20__ : immediate20=ty d1_d2_d3=nofnop;
#            ori__  : rt=1 rs=1 s_immediate=tx d1_d2_d3=nofnop;
#            bne__ : rs=rsrc1 rt=1 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#         end,
#
#bgt rsrc1 src2 address macro
#          begin
#             if twelve_bit_signed_constant(src2) then
#                slti__: rt=1 rs=rsrc1 s_immediate=src2 d1_d2_d3=nofnop
#             else
#                begin
#                   ty = src2.[31:20];
#                   tx = src2.[11:12];
#                   lui20__ : immediate20=ty d1_d2_d3=nofnop;
#                   if tx then
#                      ori__ : rt=1 rs=1 s_immediate=tx d1_d2_d3=nofnop;
#                   slt__: rd=1 rs=1 rt=rsrc1 d1_d2_d3=nofnop;
#                end;
#             bne__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#bgt rsrc1 rsrc2 address macro
#          begin
#             slt__ : rd=1 rs=rsrc2 rt=rsrc1 d1_d2_d3=nofnop;
#             bne__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#bgtu rsrc1 rsrc2 address macro
#          begin
#             sltu__: rd=1 rs=rsrc2 rt=rsrc1 d1_d2_d3=nofnop;
#             bne__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#ble rsrc1 src2 address macro
#          begin
#             if twelve_bit_signed_constant(src2) then
#                slti__: rt=1 rs=rsrc1 s_immediate=src2 d1_d2_d3=nofnop
#             else
#                begin
#                   ty = src2.[31:20];
#                   tx = src2.[11:12];
#                   lui20__ : immediate20=ty d1_d2_d3=nofnop;
#                   if tx then
#                      ori__ : rt=1 rs=1 s_immediate=tx d1_d2_d3=nofnop;
#                   slt__: rd=1 rs=1 rt=rsrc1 d1_d2_d3=nofnop;
#                end;
#             beq__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#ble rsrc1 rsrc2 address macro
#          begin
#             slt__ : rd=1 rs=rsrc2 rt=rsrc1 d1_d2_d3=nofnop;
#             beq__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#bleu rsrc1 rsrc2 address macro
#          begin
#             sltu__: rd=1 rs=rsrc2 rt=rsrc1 d1_d2_d3=nofnop;
#             beq__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#blt rsrc1 src2 address macro
#          begin
#             if twelve_bit_signed_constant(src2) then
#                slti__: rt=1 rs=rsrc1 s_immediate=src2 d1_d2_d3=nofnop
#             else
#                begin
#                   ty = src2.[31:20];
#                   tx = src2.[11:12];
#                   lui20__ : immediate20=ty d1_d2_d3=nofnop;
#                   if tx then
#                      ori__ : rt=1 rs=1 s_immediate=tx d1_d2_d3=nofnop;
#                   slt__: rd=1 rs=rsrc1 rt=1 d1_d2_d3=nofnop;
#                end;
#             bne__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#blt rsrc1 rsrc2 address macro
#          begin
#             slt__ : rd=1 rs=rsrc1 rt=rsrc2 d1_d2_d3=nofnop;
#             bne__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#bltu rsrc1 rsrc2 address macro
#          begin
#             sltu__: rd=1 rs=rsrc1 rt=rsrc2 d1_d2_d3=nofnop;
#             bne__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#   beq rsrc1 src2 address macro
#         begin
#            ty = src2.[31:20];
#            tx = src2.[11:12];
#            lui20__ : immediate20=ty d1_d2_d3=nofnop;
#            ori__   : rt=1 rs=1 s_immediate=tx d1_d2_d3=nofnop;
#            beq__ : rs=rsrc1 rt=1 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#         end,
#
#bge rsrc1 src2 address macro
#          begin
#             if twelve_bit_signed_constant(src2) then
#                slti__: rt=1 rs=rsrc1 s_immediate=src2 d1_d2_d3=nofnop
#             else
#                begin
#                   ty = src2.[31:20];
#                   tx = src2.[11:12];
#                   lui20__ : immediate20=ty d1_d2_d3=nofnop;
#                   if tx then
#                      ori__ : rt=1 rs=1 s_immediate=tx d1_d2_d3=nofnop;
#                   slt__: rd=1 rs=rsrc1 rt=1 d1_d2_d3=nofnop;
#                end;
#             beq__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#bge rsrc1 rsrc2 address macro
#          begin
#             slt__ : rd=1 rs=rsrc1 rt=rsrc2 d1_d2_d3=nofnop;
#             beq__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#
#bgeu rsrc1 rsrc2 address macro
#          begin
#             sltu__: rd=1 rs=rsrc1 rt=rsrc2 d1_d2_d3=nofnop;
#             beq__ : rs=1 rt=0 s_immediate=<address.delta.branch_address> d1_d2_d3=nofnop;
#          end,
#


####################################### DDE START #########################################

type
   sd_rop       integer        field          25   1,
   sd_pop	integer        field          2    1,
   sd_lop       integer        field          25   1,
   rop_base     register       fixedfield     24   6,
   rop_disp     register       fixedfield     18   6,
   lop_base     register       fixedfield     24   6,
   lop_disp     register       fixedfield     18   6,
   pop_base     register       fixedfield     12   6,
   pop_disp     register       fixedfield      6   6,
   func_f       constant       field          12   6,
   fmt          constant       field           6   4,
   rev          constant       field           1   1,
   uconstant    integer        field          25  23,
   displacement integer        field          18  16;


procedure sign_extend_23 (x:9)
begin
   sign_extend_23=(x.[8:1] |< 23) || x;
end sign_extend_23;

procedure zero_extend_23 (x:23)
begin
   zero_extend_23=x & 0x7fffff;
end zero_extend_23;


#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
# Demand Driven Execution(DDE) Instruction Set
#
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#

bitconstant
   #
   #- D-Format instructions
   #  ----------------------------------------
   #            31..29  28..26
   #            ------  ------
   #unused      0 0 0   0 0 0 ,    #- D format #_syscall
   _dd_add      0 0 0   0 0 1 ,    #- D format
   _dd_addu     0 0 0   0 1 0 ,    #- D format
   _dd_and      0 0 0   0 1 1 ,    #- D format
   #unused      0 0 0   1 0 0 ,    #- D format #_break
   _dd_div      0 0 0   1 0 1 ,    #- D format # redefined for dde
   _dd_divu     0 0 0   1 1 0 ,    #- D format # redefined for dde
   #eta         0 0 0   1 1 1 ,    #- D format #_jalr
   #psi         0 0 1   0 0 0 ,    #- D format #_jr
   #thn         0 0 1   0 0 1 ,    #- D format #_mfhi
   #with        0 0 1   0 1 0 ,    #- D format #_mflo
   #either      0 0 1   0 1 1 ,    #- D format #_mtlo
   _dd_mul      0 0 1   1 0 0 ,    #- D format #_mult  # redefined for dde
   _dd_mulu     0 0 1   1 0 1 ,    #- D format #_multu # redefined for dde
   _dd_nor      0 0 1   1 1 0 ,    #- D format
   _dd_or       0 0 1   1 1 1 ,    #- D format
   _dd_sll      0 1 0   0 0 0 ,    #- D format
   #unused      0 1 0   0 0 1 ,    #- D format #_sllv
   _dd_slt      0 1 0   0 1 0 ,    #- D format
   _dd_sltu     0 1 0   0 1 1 ,    #- D format
   _dd_sra      0 1 0   1 0 0 ,    #- D format
   #unused      0 1 0   1 0 1 ,    #- D format #_srav
   _dd_srl      0 1 0   1 1 0 ,    #- D format
   #unused      0 1 0   1 1 1 ,    #- D format #_srlv
   _dd_sub      0 1 1   0 0 0 ,    #- D format
   _dd_subu     0 1 1   0 0 1 ,    #- D format
   _dd_xor      0 1 1   0 1 0 ,    #- D format



   #- C-Format instructions
   #  ------------------------------------------
   #            31..29  28..26
   #            ------  ------
   _dd_li       1 0 0   0 1 1 ,    #- C format
   _dd_addi     1 0 0   1 0 0 ,    #- C format
   _dd_addiu    1 0 0   1 0 1 ,    #- C format
   _dd_slti     1 0 0   1 1 0 ,    #- C format
   _dd_sltiu    1 0 0   1 1 1 ,    #- C format
   _dd_andi     1 0 1   0 0 0 ,    #- C format
   _dd_ori      1 0 1   0 0 1 ,    #- C format
   #unused      1 0 1   0 1 0 ,    #- C format #_addia # was unused. Set for inst splits.
   _dd_xori     1 0 1   0 1 1 ,    #- C format


   #- M-Format instructions
   #  ------------------------------------------
   #            31..29  28..26
   #            ------  ------
#  _lwr         1 0 1   1 0 0 ,    #- M format #currently available
#  _swr         1 0 1   1 0 1 ,    #- M format #currently available
#  _lb          1 0 1   1 1 0 ,    #- M format
#  _lbu         1 0 1   1 1 1 ,    #- M format
#  _sb          1 1 0   0 0 0 ,    #- M format
   #lwd         1 1 0   0 0 1 ,    #- M format #_lwc0
   #swd         1 1 0   0 1 0 ,    #- M format #_swc0
#  _lh          1 1 0   0 1 1 ,    #- M format
#  _lhu         1 1 0   1 0 0 ,    #- M format
#  _sh          1 1 0   1 0 1 ,    #- M format
   #unused      1 1 0   1 1 0 ,    #- M format #_lwc1
   #unused      1 1 0   1 1 1 ,    #- M format #_swc1
#  _lwl         1 1 1   0 0 0 ,    #- M format #currently available
#  _swl         1 1 1   0 0 1 ,    #- M format #currently available
   _dd_lw       1 1 1   0 1 0 ,    #- M format
   _dd_sw       1 1 1   0 1 1 ,    #- M format


   _dde         1 1 1   1 1 1 ;


instruction
#---------------------------- Start  ------- DDE Instructions------------------------------------#

#- DD_ADD : DDE Add word- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_add sd_rop rop_base rop_disp sd_pop
         emit opcode=_dd_add sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :none,              l_dest2_r:none,              l_lop_r  :none,
              l_lop2_r :none,              l_rop_r  :rop_base,          l_rop2_r :rop_disp
             )
         begin
            exact s_EX
                  dest=lop + rop;
            end;
         end,

#- DD_ADDI : DDE Add Immediate word- - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_addi uconstant sd_pop
     emit opcode=_dd_addi uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,    i_cycles :single_cycle,     exu      :integer_unit,
      c_what   :none,             c_detail :none,             dest_type:integer_register,
      lop_type :integer_register, rop_type :none,             i_type   :alu_type,
      l_dest_r :none,             l_dest2_r:none,             l_lop_r  :none,
      l_lop2_r :none,             l_rop_r  :none,             l_rop2_r :none
     )
     begin
        exact s_ID
              scon=sign_extend_23(uconstant);
        end;

        exact s_EX
              dest=lop + scon;
        end;
     end,

#- DDE_ADDIU : DDE Add immediate unsigned word- - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_addiu uconstant sd_pop
         emit opcode=_dd_addiu uconstant sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :none,              l_dest2_r:none,              l_lop_r  :none,
              l_lop2_r :none,              l_rop_r  :none,              l_rop2_r :none
             )
         begin
            exact s_ID
                  scon=sign_extend_23(uconstant);
            end;

            exact s_EX
                  dest=lop + scon;
            end;
         end,

#- DD_ADDU : DDE Add unsigned word- - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_addu sd_rop rop_base rop_disp sd_pop
         emit opcode=_dd_addu sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :none,              l_dest2_r:none,              l_lop_r  :none,
              l_lop2_r :none,              l_rop_r  :rop_base,          l_rop2_r :rop_disp
             )
         begin
            exact s_EX
                  dest=lop + rop;
            end;
         end,

#- DD_AND : DDE And- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_and sd_rop rop_base rop_disp sd_pop
         emit opcode=_dd_and sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :none,              l_dest2_r:none,              l_lop_r  :none,
              l_lop2_r :none,              l_rop_r  :rop_base,          l_rop2_r :rop_disp
             )
         begin
            exact s_EX
                  dest=lop & rop;
            end;
         end,

#- DD_ANDI : DDE And Immediate- - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_andi uconstant sd_pop
     emit opcode=_dd_andi uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,     exu      :integer_unit,
      c_what   :none,                 c_detail :none,             dest_type:integer_register,
      lop_type :integer_register,     rop_type :none,             i_type   :alu_type,
      l_dest_r :none,                 l_dest2_r:none,             l_lop_r  :none,
      l_lop2_r :none,                 l_rop_r  :none,             l_rop2_r :none
     )
     begin
        exact s_ID
              zimm=zero_extend_23(uconstant);
        end;

        exact s_EX
              dest=lop & zimm;
        end;
     end,

#- DDE : DDE extension for instruction- - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dde sd_lop lop_base lop_disp pop_base pop_disp
         emit opcode=_dde sd_lop lop_base lop_disp pop_base pop_disp cf=0
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :none,              l_dest2_r:none,              l_lop_r  :lop_base,
              l_lop2_r :lop_disp,          l_rop_r  :pop_base,          l_rop2_r :pop_disp
             )
         ,

#- DD_DIV : DDE Divide word- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS 32 #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_div sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_div sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :long_integer_class,    i_cycles :multiple_cycles,         exu      :integer_unit,
      c_what   :none,                  c_detail :none,                    dest_type:lo_hi_register,
      lop_type :integer_register,      rop_type :integer_register,        i_type   :alu_type,
      l_dest_r :none,                  l_dest2_r:none,                    l_lop_r  :none,
      l_lop2_r :none,                  l_rop_r  :rop_base,                l_rop2_r :rop_disp
     )
     begin
        exact s_ID
              latency 7; # was 32;
        end;

        exact s_EX
              if rop == 0 then
                 exception = 1
              else
                begin
                    dest2 = lop / rop;
                    dest  = lop % rop;
                end;
         end;
     end,

#- DD_DIVU : DDE Divide word unsigned- - - - - - - - - - - - - - - - - - - - - - - - - - MIPS 32 #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_divu sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_divu sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :long_integer_class,    i_cycles :multiple_cycles,         exu      :integer_unit,
      c_what   :none,                  c_detail :none,                    dest_type:lo_hi_register,
      lop_type :integer_register,      rop_type :integer_register,        i_type   :alu_type,
      l_dest_r :none,                  l_dest2_r:none,                    l_lop_r  :none,
      l_lop2_r :none,                  l_rop_r  :rop_base,                l_rop2_r :rop_disp
     )
     begin
        exact s_ID
              latency 7; # was 32;
        end;

        exact s_EX
              if rop == 0 then
                 exception = 1
              else
                begin
                    dest2  =(+ lop) / (+ rop);
                    dest   =(+ lop) % (+ rop);
                end;
         end;
     end,

#- DDE_LI : Load immediate 23 bit constant- - - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_li uconstant sd_pop
         emit opcode=_dd_li uconstant sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,   i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,            c_detail  :none,              dest_type :integer_register,
              lop_type :none,            rop_type  :none,              i_type    :alu_type,
              l_dest_r :none,            l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r :none,            l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_ID
                  scon=sign_extend_23(uconstant);
            end;

            exact s_EX
                  dest=scon;
            end;
         end,

#- DD_LW  : DDE Load word- - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                             #
#  MIPS I.                                                                    #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
   dd_lw sd_rop rop_base displacement sd_pop
         emit opcode=_dd_lw sd_rop rop_base displacement sd_pop rev=0 cf=0
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : load_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : integer_register,
              lop_type  : integer_register,
              rop_type  : none,
              i_type    : load_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : none,
              l_lop2_r  : none,
              l_rop_r   : rop_base,
              l_rop2_r  : displacement
             )
         begin
            exact s_ID
                  disp=sign_extend_16(displacement);
            end;

            exact s_EX
                  lmar=rop + disp;
            end;

            exact s_MEM
                  if ls_bypass then
                     dest=dest2
                  else
                     begin
                        dest=dcache [lmar];
                        mem_stat=access_complete;
                     end;
            end;
         end,

#- DD_MUL: DDE Multiply word - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS 32 #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_mul sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_mul sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :long_integer_class,    i_cycles :multiple_cycles,          exu      :integer_unit,
      c_what   :none,                  c_detail :none,                     dest_type:integer_register,
      lop_type :integer_register,      rop_type :integer_register,         i_type   :alu_type,
      l_dest_r :none,                  l_dest2_r:none,                     l_lop_r  :none,
      l_lop2_r :none,                  l_rop_r  :rop_base,                 l_rop2_r :rop_disp
     )
     begin
        exact s_ID
              latency 3;
        end;

        exact s_EX
              builtin long_signed_multiply(lop,rop,hi_val,lo_val);             # To verify
              dest=lo_val;
        end;
     end,

#- DD_MULU: DDE Multiply unsigned word - - - - - - - - - - - - - - - - - - - - - - - - - MIPS 32 #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_mulu sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_mulu sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :long_integer_class,    i_cycles :multiple_cycles,          exu      :integer_unit,
      c_what   :none,                  c_detail :none,                     dest_type:integer_register,
      lop_type :integer_register,      rop_type :integer_register,         i_type   :alu_type,
      l_dest_r :none,                  l_dest2_r:none,                     l_lop_r  :none,
      l_lop2_r :none,                  l_rop_r  :rop_base,                 l_rop2_r :rop_disp
     )
     begin
        exact s_ID
              latency 3;
        end;

        exact s_EX
              builtin long_multiply(lop,rop,hi_val,lo_val);             # To verify
              dest=lo_val;
        end;
     end,

#- DD_NOR : DDE Not or- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_nor sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_nor sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,       i_cycles :single_cycle,          exu      :integer_unit,
      c_what   :none,                c_detail :none,                  dest_type:integer_register,
      lop_type :integer_register,    rop_type :integer_register,      i_type   :alu_type,
      l_dest_r :none,                l_dest2_r:none,                  l_lop_r  :none,
      l_lop2_r :none,                l_rop_r  :rop_base,              l_rop2_r :rop_disp
     )
     begin
        exact s_EX
              dest=(lop | rop) ^ 0xffffffff;
        end;
     end,

#- DD_OR : DDE Or- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_or sd_rop rop_base rop_disp sd_pop
      emit opcode=_dd_or sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
      attributes
      (
       i_class :integer_class,       i_cycles :single_cycle,         exu      :integer_unit,
       c_what  :none,                c_detail :none,                 dest_type:integer_register,
       lop_type:integer_register,    rop_type :integer_register,     i_type   :alu_type,
       l_dest_r:none,                l_dest2_r:none,                 l_lop_r  :none,
       l_lop2_r:none,                l_rop_r  :rop_base,             l_rop2_r :rop_disp
      )
      begin
         exact s_EX
               dest=lop | rop;
         end;
      end,

#- DD_ORI : DDE Or Immediate- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_ori uconstant sd_pop
     emit opcode=_dd_ori uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class   : integer_class,          i_cycles  : single_cycle,     exu       : integer_unit,
      c_what    : none,                   c_detail  : none,             dest_type : integer_register,
      lop_type  : integer_register,       rop_type  : none,             i_type    : alu_type,
      l_dest_r  : none,                   l_dest2_r : none,             l_lop_r   : none,
      l_lop2_r  : none,                   l_rop_r   : none,             l_rop2_r  : none
     )
     begin
        exact s_ID
              zimm=zero_extend_23(uconstant);
        end;

        exact s_EX
              dest=lop | zimm;
        end;
     end,

#- DD_SLL : DDE Shift word left logical - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_sll uconstant sd_pop
         emit opcode=_dd_sll uconstant sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,    i_cycles  :single_cycle,      exu       :integer_unit,
              c_what   :none,             c_detail  :none,              dest_type :integer_register,
              lop_type :none,             rop_type  :integer_register,  i_type    :alu_type,
              l_dest_r :none,             l_dest2_r :none,              l_lop_r   :none,
              l_lop2_r :none,             l_rop_r   :none,              l_rop2_r  :none
             )
         begin
            exact s_EX
                  dest=(+lop) << (+uconstant);   # To verify
            end;
         end,

#- DD_SLT : DDE Set on Less than- - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_slt sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_slt sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,       i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,    rop_type :integer_register,     i_type   :alu_type,
      l_dest_r :none,                l_dest2_r:none,                 l_lop_r  :none,
      l_lop2_r :none,                l_rop_r  :rop_base,             l_rop2_r :rop_disp
     )
     begin
        exact s_EX
              dest=lop < rop;
        end;
     end,

#- DD_SLTI : DDE Set on Less than Immediate- - - - - - - - - - - - - - - - - - - - - - - MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_slti uconstant sd_pop
     emit opcode=_dd_slti uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                 c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,     rop_type :none,                 i_type   :alu_type,
      l_dest_r :none,                 l_dest2_r:none,                 l_lop_r  :none,
      l_lop2_r :none,                 l_rop_r  :none,                 l_rop2_r :none
     )
     begin
        exact s_ID
              scon=sign_extend_23(uconstant);
        end;

        exact s_EX
              dest=lop < scon;
              # builtin printf("LOP=%d SIMM=%d Less=%d\n\n",lop,simm,dest);
        end;
     end,

#- DD_SLTIU : DDE Set on Less than Immediate Unsigned- - - - - - - - - - - - - - - - - - MIPS-I -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_sltiu uconstant sd_pop
     emit opcode=_dd_sltiu uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class   : integer_class,       i_cycles  : single_cycle,     exu       : integer_unit,
      c_what    : none,                c_detail  : none,             dest_type : integer_register,
      lop_type  : integer_register,    rop_type  : none,             i_type    : alu_type,
      l_dest_r  : none,                l_dest2_r : none,             l_lop_r   : none,
      l_lop2_r  : none,                l_rop_r   : none,             l_rop2_r  : none
     )
     begin
        exact s_ID
              scon=sign_extend_23(uconstant);
        end;

        exact s_EX
              dest=(+ lop) < (+ scon);               #MARK must be unsigned.
        end;
     end,

#- DD_SLTU : DDE Set on Less than unsigned - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_sltu sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_sltu sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,        i_cycles :single_cycle,         exu      :integer_unit,
      c_what   :none,                 c_detail :none,                 dest_type:integer_register,
      lop_type :integer_register,     rop_type :integer_register,     i_type   :alu_type,
      l_dest_r :none,                 l_dest2_r:none,                 l_lop_r  :none,
      l_lop2_r :none,                 l_rop_r  :rop_base,             l_rop2_r :rop_disp
     )
     begin
        exact s_EX
              dest=(+ lop) < (+ rop);            #MARK Must be unsigned.
        end;
     end,

#- DD_SRA : DDE Shift word right arithmetic - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_sra uconstant sd_pop
     emit opcode=_dd_sra uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,    i_cycles :single_cycle,        exu      :integer_unit,
      c_what   :none,             c_detail :none,                dest_type:integer_register,
      lop_type :none,             rop_type :integer_register,    i_type   :alu_type,
      l_dest_r :none,             l_dest2_r:none,                l_lop_r  :none,
      l_lop2_r :none,             l_rop_r  :none,                l_rop2_r :none
     )
     begin
        exact s_EX
              dest=lop >> uconstant;
        end;
     end,

#- DD_SRL : DDE Shift word right logical- - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_srl uconstant sd_pop
     emit opcode=_dd_srl uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,   i_cycles :single_cycle,           exu      :integer_unit,
      c_what   :none,            c_detail :none,                   dest_type:integer_register,
      lop_type :none,            rop_type :integer_register,       i_type   :alu_type,
      l_dest_r :none,            l_dest2_r:none,                   l_lop_r  :none,
      l_lop2_r :none,            l_rop_r  :none,                   l_rop2_r :none
     )
     begin
        exact s_EX
              dest=(+lop) >> (+uconstant);
        end;
     end,

#- DD_SUB : Substract word- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_sub sd_rop rop_base rop_disp sd_pop
         emit opcode=_dd_sub sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :none,              l_dest2_r:none,              l_lop_r  :none,
              l_lop2_r :none,              l_rop_r  :rop_base,          l_rop2_r :rop_disp
             )
         begin
            exact s_EX
                  dest=lop - rop;
            end;
         end,

#- DD_SUBU : DDE Substract unsigned word- - - - - - - - - - - - - - - - - - - - - - - - - - - - MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_subu sd_rop rop_base rop_disp sd_pop
         emit opcode=_dd_subu sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
         attributes
             (
              i_class  :integer_class,     i_cycles :single_cycle,      exu      :integer_unit,
              c_what   :none,              c_detail :none,              dest_type:integer_register,
              lop_type :integer_register,  rop_type :integer_register,  i_type   :alu_type,
              l_dest_r :none,              l_dest2_r:none,              l_lop_r  :none,
              l_lop2_r :none,              l_rop_r  :rop_base,          l_rop2_r :rop_disp
             )
         begin
            exact s_EX
                  dest=lop - rop;
            end;
         end,

#- DDE_SW : DDE Store word - - - - - - - - - - - - - - - - - - - - - - - - - -#
#                                                                             #
#  MIPS I.                                                                    #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -#
   dd_sw sd_rop rop_base displacement sd_pop
         emit opcode=_dd_sw sd_rop rop_base displacement sd_pop rev=0 cf=0
         attributes
             (
              i_class   : integer_class,
              i_cycles  : multiple_cycles,
              exu       : store_unit,
              c_what    : none,
              c_detail  : none,
              dest_type : none,
              lop_type  : integer_register,
              rop_type  : integer_register,
              i_type    : store_type,
              l_dest_r  : none,
              l_dest2_r : none,
              l_lop_r   : none,
              l_lop2_r  : none,
              l_rop_r   : rop_base,
              l_rop2_r  : displacement
             )
         begin
            exact s_ID
                  disp=sign_extend_16(displacement);
            end;

            exact s_EX
                  smar=rop + disp;
                  smdr=rop;
                  access_type=_WORD;
            end;
         end,

#- DD_XOR: DDE Exclusive Or- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  MIPS I #
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_xor sd_rop rop_base rop_disp sd_pop
     emit opcode=_dd_xor sd_rop rop_base rop_disp func_f=0 fmt=0 sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,      i_cycles :single_cycle,           exu      :integer_unit,
      c_what   :none,               c_detail :none,                   dest_type:integer_register,
      lop_type :integer_register,   rop_type :integer_register,       i_type   :alu_type,
      l_dest_r :none,               l_dest2_r:none,                   l_lop_r  :none,
      l_lop2_r :none,               l_rop_r  :rop_base,               l_rop2_r :rop_disp
     )
     begin
        exact s_EX
              dest=lop ^ rop;
        end;
     end,

#- DD_XORI: DDE Exclusive Or Immediate - - - - - - - - - - - - - - - - - - - - - - - - - - LAZY -#
#                                                                                                #
#  Description.                                                                                  #
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
   dd_xori uconstant sd_pop
     emit opcode=_dd_xori uconstant sd_pop rev=0 cf=0
     attributes
     (
      i_class  :integer_class,          i_cycles :single_cycle,      exu      :integer_unit,
      c_what   :none,                   c_detail :none,              dest_type:integer_register,
      lop_type :integer_register,       rop_type :none,              i_type   :alu_type,
      l_dest_r :none,                   l_dest2_r:none,              l_lop_r  :none,
      l_lop2_r :none,                   l_rop_r  :none,              l_rop2_r :none
     )
     begin
        exact s_ID
              zimm=zero_extend_23(uconstant);
        end;

        exact s_EX
              dest=lop ^ zimm;
        end;
     end;

#------------------------------ End -- of --- DDE Instructions ----------------------------------#
